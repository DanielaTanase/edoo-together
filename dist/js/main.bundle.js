(() => {
  // src/js/data.js
  var data = [
    {
      "id": 1,
      "title": "Practical Node.js Course",
      "description": "Get started with Node.js and create your first application.",
      "image": "https://picsum.photos/300/300?random=1",
      "authors": "Alice Johnson, Bob Brown, John Doe",
      "price": "159.99\u20AC",
      "paid": false,
      "language": [
        "Spanish",
        "German",
        "French",
        "Italian"
      ],
      "topic": "Node.js",
      "level": "Beginner"
    },
    {
      "id": 2,
      "title": "Ultimate React Course",
      "description": "Boost your coding skills with this Beginner React course.",
      "image": "https://picsum.photos/300/300?random=2",
      "authors": "Bob Brown, Emily White, David Garcia",
      "price": "33.99\u20AC",
      "paid": false,
      "language": [
        "German",
        "Spanish",
        "English",
        "French",
        "Italian"
      ],
      "topic": "React",
      "level": "Expert"
    },
    {
      "id": 3,
      "title": "Essential Javascript Course",
      "description": "Step-by-step instructions to become proficient in Javascript.",
      "image": "https://picsum.photos/300/300?random=3",
      "authors": "David Garcia, John Doe",
      "price": "67.99\u20AC",
      "paid": false,
      "language": [
        "Italian",
        "Spanish",
        "English",
        "French",
        "German"
      ],
      "topic": "Javascript",
      "level": "Beginner"
    },
    {
      "id": 4,
      "title": "Ultimate React Course",
      "description": "Boost your coding skills with this Expert React course.",
      "image": "https://picsum.photos/300/300?random=4",
      "authors": "Charlie Davis, Bob Brown, John Doe",
      "price": "74.99\u20AC",
      "paid": true,
      "language": [
        "French",
        "Italian",
        "German",
        "Spanish",
        "English"
      ],
      "topic": "React",
      "level": "Intermediate"
    },
    {
      "id": 5,
      "title": "Complete Node.js Course",
      "description": "A deep dive into Node.js to take your skills to the next level.",
      "image": "https://picsum.photos/300/300?random=5",
      "authors": "Charlie Davis, David Garcia, Bob Brown",
      "price": "73.99\u20AC",
      "paid": true,
      "language": [
        "English",
        "Italian"
      ],
      "topic": "Node.js",
      "level": "Beginner"
    },
    {
      "id": 6,
      "title": "Comprehensive Node.js Course",
      "description": "A comprehensive guide to Node.js for Expert developers.",
      "image": "https://picsum.photos/300/300?random=6",
      "authors": "Jane Smith, John Doe, Emily White",
      "price": "84.99\u20AC",
      "paid": false,
      "language": [
        "Spanish",
        "German",
        "Italian",
        "French",
        "English"
      ],
      "topic": "Node.js",
      "level": "Beginner"
    },
    {
      "id": 7,
      "title": "Essential Node.js Course",
      "description": "Get started with Node.js and create your first application.",
      "image": "https://picsum.photos/300/300?random=7",
      "authors": "Charlie Davis, Bob Brown, Emily White",
      "price": "77.99\u20AC",
      "paid": true,
      "language": [
        "English",
        "German",
        "Spanish",
        "French",
        "Italian"
      ],
      "topic": "Node.js",
      "level": "Expert"
    },
    {
      "id": 8,
      "title": "Complete Next.js Course",
      "description": "A deep dive into Next.js to take your skills to the next level.",
      "image": "https://picsum.photos/300/300?random=8",
      "authors": "John Doe, Alice Johnson, Emily White",
      "price": "172.99\u20AC",
      "paid": true,
      "language": [
        "Italian",
        "Spanish",
        "German",
        "French",
        "English"
      ],
      "topic": "Next.js",
      "level": "Intermediate"
    },
    {
      "id": 9,
      "title": "Ultimate Node.js Course",
      "description": "A comprehensive guide to Node.js for Intermediate developers.",
      "image": "https://picsum.photos/300/300?random=9",
      "authors": "Bob Brown",
      "price": "44.99\u20AC",
      "paid": true,
      "language": [
        "German",
        "Spanish"
      ],
      "topic": "Node.js",
      "level": "Beginner"
    },
    {
      "id": 10,
      "title": "Practical Node.js Course",
      "description": "Get started with Node.js and create your first application.",
      "image": "https://picsum.photos/300/300?random=10",
      "authors": "Charlie Davis, Sophia Martinez, David Garcia",
      "price": "83.99\u20AC",
      "paid": true,
      "language": [
        "French",
        "German"
      ],
      "topic": "Node.js",
      "level": "Expert"
    },
    {
      "id": 11,
      "title": "Practical HTML Course",
      "description": "A deep dive into HTML to take your skills to the next level.",
      "image": "https://picsum.photos/300/300?random=11",
      "authors": "Emily White",
      "price": "25.99\u20AC",
      "paid": true,
      "language": [
        "Spanish",
        "Italian",
        "English"
      ],
      "topic": "HTML",
      "level": "Intermediate"
    },
    {
      "id": 12,
      "title": "Practical HTML Course",
      "description": "A deep dive into HTML to take your skills to the next level.",
      "image": "https://picsum.photos/300/300?random=12",
      "authors": "Bob Brown, Sophia Martinez, Alice Johnson",
      "price": "153.99\u20AC",
      "paid": false,
      "language": [
        "Italian"
      ],
      "topic": "HTML",
      "level": "Intermediate"
    },
    {
      "id": 13,
      "title": "Advanced CSS Course",
      "description": "Get started with CSS and create your first application.",
      "image": "https://picsum.photos/300/300?random=13",
      "authors": "David Garcia",
      "price": "163.99\u20AC",
      "paid": true,
      "language": [
        "German",
        "English"
      ],
      "topic": "CSS",
      "level": "Intermediate"
    },
    {
      "id": 14,
      "title": "Advanced Javascript Course",
      "description": "Get started with Javascript and create your first application.",
      "image": "https://picsum.photos/300/300?random=14",
      "authors": "David Garcia",
      "price": "165.99\u20AC",
      "paid": false,
      "language": [
        "German",
        "Spanish",
        "French",
        "English",
        "Italian"
      ],
      "topic": "Javascript",
      "level": "Expert"
    },
    {
      "id": 15,
      "title": "Ultimate CSS Course",
      "description": "Get started with CSS and create your first application.",
      "image": "https://picsum.photos/300/300?random=15",
      "authors": "Charlie Davis, Alice Johnson, David Garcia",
      "price": "43.99\u20AC",
      "paid": false,
      "language": [
        "French",
        "Italian",
        "English"
      ],
      "topic": "CSS",
      "level": "Intermediate"
    },
    {
      "id": 16,
      "title": "Comprehensive Next.js Course",
      "description": "Perfect your Next.js knowledge with interactive exercises and challenges.",
      "image": "https://picsum.photos/300/300?random=16",
      "authors": "Sophia Martinez",
      "price": "44.99\u20AC",
      "paid": true,
      "language": [
        "German"
      ],
      "topic": "Next.js",
      "level": "Intermediate"
    },
    {
      "id": 17,
      "title": "Practical Javascript Course",
      "description": "Boost your coding skills with this Beginner Javascript course.",
      "image": "https://picsum.photos/300/300?random=17",
      "authors": "John Doe, Bob Brown",
      "price": "176.99\u20AC",
      "paid": false,
      "language": [
        "English",
        "Spanish",
        "German"
      ],
      "topic": "Javascript",
      "level": "Beginner"
    },
    {
      "id": 18,
      "title": "Practical Node.js Course",
      "description": "A comprehensive guide to Node.js for Expert developers.",
      "image": "https://picsum.photos/300/300?random=18",
      "authors": "Sophia Martinez",
      "price": "187.99\u20AC",
      "paid": true,
      "language": [
        "German",
        "Italian",
        "Spanish",
        "English"
      ],
      "topic": "Node.js",
      "level": "Beginner"
    },
    {
      "id": 19,
      "title": "Advanced Next.js Course",
      "description": "Get started with Next.js and create your first application.",
      "image": "https://picsum.photos/300/300?random=19",
      "authors": "Emily White, Alice Johnson, Bob Brown",
      "price": "101.99\u20AC",
      "paid": true,
      "language": [
        "German",
        "French",
        "English"
      ],
      "topic": "Next.js",
      "level": "Beginner"
    },
    {
      "id": 20,
      "title": "Essential HTML Course",
      "description": "Learn the fundamentals of HTML with this hands-on course.",
      "image": "https://picsum.photos/300/300?random=20",
      "authors": "Bob Brown, Charlie Davis",
      "price": "162.99\u20AC",
      "paid": false,
      "language": [
        "French",
        "Spanish"
      ],
      "topic": "HTML",
      "level": "Expert"
    },
    {
      "id": 21,
      "title": "Advanced Node.js Course",
      "description": "Step-by-step instructions to become proficient in Node.js.",
      "image": "https://picsum.photos/300/300?random=21",
      "authors": "Sophia Martinez, Emily White",
      "price": "59.99\u20AC",
      "paid": true,
      "language": [
        "Spanish",
        "French",
        "Italian",
        "English"
      ],
      "topic": "Node.js",
      "level": "Intermediate"
    },
    {
      "id": 22,
      "title": "Advanced CSS Course",
      "description": "Get started with CSS and create your first application.",
      "image": "https://picsum.photos/300/300?random=22",
      "authors": "David Garcia",
      "price": "132.99\u20AC",
      "paid": true,
      "language": [
        "English",
        "German",
        "Spanish",
        "French",
        "Italian"
      ],
      "topic": "CSS",
      "level": "Beginner"
    },
    {
      "id": 23,
      "title": "Complete Node.js Course",
      "description": "Master Node.js with real-world projects and expert guidance.",
      "image": "https://picsum.photos/300/300?random=23",
      "authors": "Sophia Martinez, John Doe, Jane Smith",
      "price": "200.99\u20AC",
      "paid": true,
      "language": [
        "German",
        "Italian",
        "French",
        "English"
      ],
      "topic": "Node.js",
      "level": "Beginner"
    },
    {
      "id": 24,
      "title": "Comprehensive Next.js Course",
      "description": "Unlock the full potential of Next.js with this extensive course.",
      "image": "https://picsum.photos/300/300?random=24",
      "authors": "Emily White, Charlie Davis",
      "price": "93.99\u20AC",
      "paid": false,
      "language": [
        "Italian",
        "German"
      ],
      "topic": "Next.js",
      "level": "Beginner"
    },
    {
      "id": 25,
      "title": "Complete Javascript Course",
      "description": "Learn the fundamentals of Javascript with this hands-on course.",
      "image": "https://picsum.photos/300/300?random=25",
      "authors": "David Garcia, Emily White",
      "price": "69.99\u20AC",
      "paid": true,
      "language": [
        "Spanish"
      ],
      "topic": "Javascript",
      "level": "Intermediate"
    },
    {
      "id": 26,
      "title": "Comprehensive HTML Course",
      "description": "A deep dive into HTML to take your skills to the next level.",
      "image": "https://picsum.photos/300/300?random=26",
      "authors": "Emily White, Jane Smith, Sophia Martinez",
      "price": "104.99\u20AC",
      "paid": true,
      "language": [
        "French"
      ],
      "topic": "HTML",
      "level": "Beginner"
    },
    {
      "id": 27,
      "title": "Comprehensive HTML Course",
      "description": "Master HTML with real-world projects and expert guidance.",
      "image": "https://picsum.photos/300/300?random=27",
      "authors": "Sophia Martinez, Charlie Davis, David Garcia",
      "price": "76.99\u20AC",
      "paid": false,
      "language": [
        "Spanish",
        "English",
        "French",
        "German"
      ],
      "topic": "HTML",
      "level": "Expert"
    },
    {
      "id": 28,
      "title": "Complete CSS Course",
      "description": "Perfect your CSS knowledge with interactive exercises and challenges.",
      "image": "https://picsum.photos/300/300?random=28",
      "authors": "Alice Johnson, Charlie Davis, Jane Smith",
      "price": "108.99\u20AC",
      "paid": false,
      "language": [
        "French",
        "Spanish",
        "Italian",
        "English"
      ],
      "topic": "CSS",
      "level": "Expert"
    },
    {
      "id": 29,
      "title": "Practical Javascript Course",
      "description": "A deep dive into Javascript to take your skills to the next level.",
      "image": "https://picsum.photos/300/300?random=29",
      "authors": "Alice Johnson",
      "price": "94.99\u20AC",
      "paid": true,
      "language": [
        "Italian",
        "French",
        "Spanish",
        "English",
        "German"
      ],
      "topic": "Javascript",
      "level": "Intermediate"
    },
    {
      "id": 30,
      "title": "Ultimate Node.js Course",
      "description": "Unlock the full potential of Node.js with this extensive course.",
      "image": "https://picsum.photos/300/300?random=30",
      "authors": "Emily White",
      "price": "73.99\u20AC",
      "paid": false,
      "language": [
        "Spanish",
        "Italian",
        "French",
        "German"
      ],
      "topic": "Node.js",
      "level": "Intermediate"
    },
    {
      "id": 31,
      "title": "Advanced React Course",
      "description": "Learn the fundamentals of React with this hands-on course.",
      "image": "https://picsum.photos/300/300?random=31",
      "authors": "Sophia Martinez, Charlie Davis",
      "price": "137.99\u20AC",
      "paid": true,
      "language": [
        "English",
        "French",
        "Italian"
      ],
      "topic": "React",
      "level": "Beginner"
    },
    {
      "id": 32,
      "title": "Comprehensive HTML Course",
      "description": "Boost your coding skills with this Intermediate HTML course.",
      "image": "https://picsum.photos/300/300?random=32",
      "authors": "John Doe, David Garcia, Jane Smith",
      "price": "150.99\u20AC",
      "paid": false,
      "language": [
        "German",
        "Italian"
      ],
      "topic": "HTML",
      "level": "Intermediate"
    },
    {
      "id": 33,
      "title": "Complete Javascript Course",
      "description": "A comprehensive guide to Javascript for Intermediate developers.",
      "image": "https://picsum.photos/300/300?random=33",
      "authors": "Bob Brown, Emily White, Sophia Martinez",
      "price": "193.99\u20AC",
      "paid": false,
      "language": [
        "German",
        "Spanish"
      ],
      "topic": "Javascript",
      "level": "Beginner"
    },
    {
      "id": 34,
      "title": "Advanced React Course",
      "description": "Master React with real-world projects and expert guidance.",
      "image": "https://picsum.photos/300/300?random=34",
      "authors": "John Doe, Emily White, Jane Smith",
      "price": "37.99\u20AC",
      "paid": true,
      "language": [
        "English",
        "Spanish",
        "French",
        "German"
      ],
      "topic": "React",
      "level": "Intermediate"
    },
    {
      "id": 35,
      "title": "Comprehensive Javascript Course",
      "description": "A comprehensive guide to Javascript for Intermediate developers.",
      "image": "https://picsum.photos/300/300?random=35",
      "authors": "Alice Johnson, John Doe, Charlie Davis",
      "price": "114.99\u20AC",
      "paid": false,
      "language": [
        "French",
        "English",
        "Italian",
        "German",
        "Spanish"
      ],
      "topic": "Javascript",
      "level": "Beginner"
    },
    {
      "id": 36,
      "title": "Advanced React Course",
      "description": "A comprehensive guide to React for Beginner developers.",
      "image": "https://picsum.photos/300/300?random=36",
      "authors": "John Doe",
      "price": "161.99\u20AC",
      "paid": true,
      "language": [
        "English",
        "Spanish"
      ],
      "topic": "React",
      "level": "Expert"
    },
    {
      "id": 37,
      "title": "Ultimate HTML Course",
      "description": "Unlock the full potential of HTML with this extensive course.",
      "image": "https://picsum.photos/300/300?random=37",
      "authors": "Alice Johnson, Charlie Davis",
      "price": "126.99\u20AC",
      "paid": true,
      "language": [
        "Italian",
        "French"
      ],
      "topic": "HTML",
      "level": "Intermediate"
    },
    {
      "id": 38,
      "title": "Complete Javascript Course",
      "description": "Boost your coding skills with this Beginner Javascript course.",
      "image": "https://picsum.photos/300/300?random=38",
      "authors": "Emily White, Jane Smith, John Doe",
      "price": "40.99\u20AC",
      "paid": false,
      "language": [
        "Spanish",
        "English",
        "Italian",
        "German"
      ],
      "topic": "Javascript",
      "level": "Intermediate"
    },
    {
      "id": 39,
      "title": "Comprehensive Next.js Course",
      "description": "Perfect your Next.js knowledge with interactive exercises and challenges.",
      "image": "https://picsum.photos/300/300?random=39",
      "authors": "Emily White",
      "price": "83.99\u20AC",
      "paid": true,
      "language": [
        "German",
        "French",
        "Spanish",
        "Italian",
        "English"
      ],
      "topic": "Next.js",
      "level": "Intermediate"
    },
    {
      "id": 40,
      "title": "Ultimate Node.js Course",
      "description": "Perfect your Node.js knowledge with interactive exercises and challenges.",
      "image": "https://picsum.photos/300/300?random=40",
      "authors": "Alice Johnson",
      "price": "180.99\u20AC",
      "paid": true,
      "language": [
        "Italian",
        "English",
        "French",
        "German",
        "Spanish"
      ],
      "topic": "Node.js",
      "level": "Expert"
    },
    {
      "id": 41,
      "title": "Ultimate Node.js Course",
      "description": "A comprehensive guide to Node.js for Beginner developers.",
      "image": "https://picsum.photos/300/300?random=41",
      "authors": "Charlie Davis, Alice Johnson, Bob Brown",
      "price": "170.99\u20AC",
      "paid": true,
      "language": [
        "English",
        "German",
        "French",
        "Italian"
      ],
      "topic": "Node.js",
      "level": "Intermediate"
    },
    {
      "id": 42,
      "title": "Complete CSS Course",
      "description": "Learn the fundamentals of CSS with this hands-on course.",
      "image": "https://picsum.photos/300/300?random=42",
      "authors": "Charlie Davis, Jane Smith",
      "price": "40.99\u20AC",
      "paid": false,
      "language": [
        "French",
        "German",
        "English"
      ],
      "topic": "CSS",
      "level": "Expert"
    },
    {
      "id": 43,
      "title": "Ultimate Node.js Course",
      "description": "Get started with Node.js and create your first application.",
      "image": "https://picsum.photos/300/300?random=43",
      "authors": "Bob Brown",
      "price": "139.99\u20AC",
      "paid": true,
      "language": [
        "Spanish",
        "Italian",
        "German",
        "French"
      ],
      "topic": "Node.js",
      "level": "Beginner"
    },
    {
      "id": 44,
      "title": "Practical Next.js Course",
      "description": "Unlock the full potential of Next.js with this extensive course.",
      "image": "https://picsum.photos/300/300?random=44",
      "authors": "Alice Johnson",
      "price": "198.99\u20AC",
      "paid": true,
      "language": [
        "French",
        "Spanish",
        "Italian"
      ],
      "topic": "Next.js",
      "level": "Expert"
    },
    {
      "id": 45,
      "title": "Advanced Node.js Course",
      "description": "A comprehensive guide to Node.js for Beginner developers.",
      "image": "https://picsum.photos/300/300?random=45",
      "authors": "David Garcia, Sophia Martinez",
      "price": "159.99\u20AC",
      "paid": true,
      "language": [
        "Italian",
        "German",
        "French",
        "English"
      ],
      "topic": "Node.js",
      "level": "Expert"
    },
    {
      "id": 46,
      "title": "Essential React Course",
      "description": "Explore advanced concepts in React and build amazing projects.",
      "image": "https://picsum.photos/300/300?random=46",
      "authors": "Emily White, Bob Brown, John Doe",
      "price": "91.99\u20AC",
      "paid": true,
      "language": [
        "French",
        "German"
      ],
      "topic": "React",
      "level": "Intermediate"
    },
    {
      "id": 47,
      "title": "Complete CSS Course",
      "description": "Step-by-step instructions to become proficient in CSS.",
      "image": "https://picsum.photos/300/300?random=47",
      "authors": "Emily White",
      "price": "59.99\u20AC",
      "paid": false,
      "language": [
        "Italian",
        "Spanish"
      ],
      "topic": "CSS",
      "level": "Expert"
    },
    {
      "id": 48,
      "title": "Complete React Course",
      "description": "Learn the fundamentals of React with this hands-on course.",
      "image": "https://picsum.photos/300/300?random=48",
      "authors": "Alice Johnson, Bob Brown",
      "price": "124.99\u20AC",
      "paid": false,
      "language": [
        "Spanish",
        "German",
        "Italian"
      ],
      "topic": "React",
      "level": "Intermediate"
    },
    {
      "id": 49,
      "title": "Practical Next.js Course",
      "description": "Perfect your Next.js knowledge with interactive exercises and challenges.",
      "image": "https://picsum.photos/300/300?random=49",
      "authors": "Emily White",
      "price": "93.99\u20AC",
      "paid": false,
      "language": [
        "English",
        "Italian",
        "French"
      ],
      "topic": "Next.js",
      "level": "Expert"
    },
    {
      "id": 50,
      "title": "Comprehensive Javascript Course",
      "description": "Learn the fundamentals of Javascript with this hands-on course.",
      "image": "https://picsum.photos/300/300?random=50",
      "authors": "Jane Smith, Charlie Davis",
      "price": "116.99\u20AC",
      "paid": true,
      "language": [
        "Spanish",
        "English",
        "French",
        "Italian"
      ],
      "topic": "Javascript",
      "level": "Intermediate"
    },
    {
      "id": 51,
      "title": "Complete Node.js Course",
      "description": "A comprehensive guide to Node.js for Intermediate developers.",
      "image": "https://picsum.photos/300/300?random=51",
      "authors": "David Garcia, Jane Smith, John Doe",
      "price": "159.99\u20AC",
      "paid": true,
      "language": [
        "English",
        "French",
        "Spanish"
      ],
      "topic": "Node.js",
      "level": "Expert"
    },
    {
      "id": 52,
      "title": "Comprehensive Node.js Course",
      "description": "Explore advanced concepts in Node.js and build amazing projects.",
      "image": "https://picsum.photos/300/300?random=52",
      "authors": "Alice Johnson",
      "price": "196.99\u20AC",
      "paid": true,
      "language": [
        "Spanish",
        "French",
        "German",
        "English"
      ],
      "topic": "Node.js",
      "level": "Intermediate"
    },
    {
      "id": 53,
      "title": "Practical HTML Course",
      "description": "Get started with HTML and create your first application.",
      "image": "https://picsum.photos/300/300?random=53",
      "authors": "Emily White, Alice Johnson, John Doe",
      "price": "50.99\u20AC",
      "paid": true,
      "language": [
        "German"
      ],
      "topic": "HTML",
      "level": "Beginner"
    },
    {
      "id": 54,
      "title": "Advanced Javascript Course",
      "description": "Explore advanced concepts in Javascript and build amazing projects.",
      "image": "https://picsum.photos/300/300?random=54",
      "authors": "John Doe, Alice Johnson",
      "price": "49.99\u20AC",
      "paid": false,
      "language": [
        "Spanish",
        "French",
        "Italian"
      ],
      "topic": "Javascript",
      "level": "Beginner"
    },
    {
      "id": 55,
      "title": "Essential Node.js Course",
      "description": "Step-by-step instructions to become proficient in Node.js.",
      "image": "https://picsum.photos/300/300?random=55",
      "authors": "John Doe, Sophia Martinez",
      "price": "188.99\u20AC",
      "paid": true,
      "language": [
        "English",
        "Spanish",
        "French",
        "Italian"
      ],
      "topic": "Node.js",
      "level": "Beginner"
    },
    {
      "id": 56,
      "title": "Practical CSS Course",
      "description": "A deep dive into CSS to take your skills to the next level.",
      "image": "https://picsum.photos/300/300?random=56",
      "authors": "John Doe, Jane Smith, Alice Johnson",
      "price": "90.99\u20AC",
      "paid": true,
      "language": [
        "English",
        "Spanish",
        "Italian",
        "German"
      ],
      "topic": "CSS",
      "level": "Intermediate"
    },
    {
      "id": 57,
      "title": "Essential HTML Course",
      "description": "A comprehensive guide to HTML for Intermediate developers.",
      "image": "https://picsum.photos/300/300?random=57",
      "authors": "Charlie Davis, Emily White",
      "price": "166.99\u20AC",
      "paid": true,
      "language": [
        "German"
      ],
      "topic": "HTML",
      "level": "Expert"
    },
    {
      "id": 58,
      "title": "Comprehensive Next.js Course",
      "description": "Explore advanced concepts in Next.js and build amazing projects.",
      "image": "https://picsum.photos/300/300?random=58",
      "authors": "Sophia Martinez, Charlie Davis, Jane Smith",
      "price": "102.99\u20AC",
      "paid": false,
      "language": [
        "French"
      ],
      "topic": "Next.js",
      "level": "Expert"
    },
    {
      "id": 59,
      "title": "Practical Javascript Course",
      "description": "A deep dive into Javascript to take your skills to the next level.",
      "image": "https://picsum.photos/300/300?random=59",
      "authors": "Jane Smith, Alice Johnson",
      "price": "177.99\u20AC",
      "paid": false,
      "language": [
        "French",
        "Spanish",
        "German"
      ],
      "topic": "Javascript",
      "level": "Expert"
    },
    {
      "id": 60,
      "title": "Advanced React Course",
      "description": "Explore advanced concepts in React and build amazing projects.",
      "image": "https://picsum.photos/300/300?random=60",
      "authors": "Alice Johnson",
      "price": "134.99\u20AC",
      "paid": true,
      "language": [
        "French",
        "German",
        "Italian",
        "English",
        "Spanish"
      ],
      "topic": "React",
      "level": "Expert"
    },
    {
      "id": 61,
      "title": "Essential React Course",
      "description": "A deep dive into React to take your skills to the next level.",
      "image": "https://picsum.photos/300/300?random=61",
      "authors": "Sophia Martinez, John Doe",
      "price": "51.99\u20AC",
      "paid": true,
      "language": [
        "English",
        "Spanish",
        "German",
        "Italian"
      ],
      "topic": "React",
      "level": "Intermediate"
    },
    {
      "id": 62,
      "title": "Advanced Javascript Course",
      "description": "Explore advanced concepts in Javascript and build amazing projects.",
      "image": "https://picsum.photos/300/300?random=62",
      "authors": "John Doe",
      "price": "125.99\u20AC",
      "paid": true,
      "language": [
        "English",
        "Spanish"
      ],
      "topic": "Javascript",
      "level": "Intermediate"
    },
    {
      "id": 63,
      "title": "Ultimate Javascript Course",
      "description": "A comprehensive guide to Javascript for Intermediate developers.",
      "image": "https://picsum.photos/300/300?random=63",
      "authors": "Sophia Martinez, Emily White, John Doe",
      "price": "96.99\u20AC",
      "paid": false,
      "language": [
        "French",
        "Italian",
        "Spanish",
        "English"
      ],
      "topic": "Javascript",
      "level": "Expert"
    },
    {
      "id": 64,
      "title": "Practical Javascript Course",
      "description": "Learn the fundamentals of Javascript with this hands-on course.",
      "image": "https://picsum.photos/300/300?random=64",
      "authors": "Bob Brown, Charlie Davis",
      "price": "41.99\u20AC",
      "paid": true,
      "language": [
        "Spanish",
        "Italian",
        "French"
      ],
      "topic": "Javascript",
      "level": "Intermediate"
    },
    {
      "id": 65,
      "title": "Ultimate Node.js Course",
      "description": "A deep dive into Node.js to take your skills to the next level.",
      "image": "https://picsum.photos/300/300?random=65",
      "authors": "Jane Smith, Alice Johnson",
      "price": "157.99\u20AC",
      "paid": true,
      "language": [
        "English"
      ],
      "topic": "Node.js",
      "level": "Beginner"
    },
    {
      "id": 66,
      "title": "Complete Node.js Course",
      "description": "Explore advanced concepts in Node.js and build amazing projects.",
      "image": "https://picsum.photos/300/300?random=66",
      "authors": "Bob Brown, Jane Smith, David Garcia",
      "price": "125.99\u20AC",
      "paid": true,
      "language": [
        "Spanish",
        "German"
      ],
      "topic": "Node.js",
      "level": "Intermediate"
    },
    {
      "id": 67,
      "title": "Comprehensive CSS Course",
      "description": "Unlock the full potential of CSS with this extensive course.",
      "image": "https://picsum.photos/300/300?random=67",
      "authors": "Emily White, John Doe",
      "price": "20.99\u20AC",
      "paid": false,
      "language": [
        "Italian",
        "French"
      ],
      "topic": "CSS",
      "level": "Intermediate"
    },
    {
      "id": 68,
      "title": "Complete Next.js Course",
      "description": "Get started with Next.js and create your first application.",
      "image": "https://picsum.photos/300/300?random=68",
      "authors": "Sophia Martinez",
      "price": "55.99\u20AC",
      "paid": false,
      "language": [
        "Spanish",
        "Italian"
      ],
      "topic": "Next.js",
      "level": "Expert"
    },
    {
      "id": 69,
      "title": "Comprehensive CSS Course",
      "description": "Unlock the full potential of CSS with this extensive course.",
      "image": "https://picsum.photos/300/300?random=69",
      "authors": "John Doe, Jane Smith, Emily White",
      "price": "153.99\u20AC",
      "paid": false,
      "language": [
        "French",
        "German"
      ],
      "topic": "CSS",
      "level": "Intermediate"
    },
    {
      "id": 70,
      "title": "Comprehensive Next.js Course",
      "description": "Explore advanced concepts in Next.js and build amazing projects.",
      "image": "https://picsum.photos/300/300?random=70",
      "authors": "Jane Smith, John Doe",
      "price": "61.99\u20AC",
      "paid": true,
      "language": [
        "Italian",
        "Spanish"
      ],
      "topic": "Next.js",
      "level": "Beginner"
    },
    {
      "id": 71,
      "title": "Advanced React Course",
      "description": "Perfect your React knowledge with interactive exercises and challenges.",
      "image": "https://picsum.photos/300/300?random=71",
      "authors": "David Garcia, Emily White, Charlie Davis",
      "price": "135.99\u20AC",
      "paid": true,
      "language": [
        "English",
        "Italian"
      ],
      "topic": "React",
      "level": "Intermediate"
    },
    {
      "id": 72,
      "title": "Essential Next.js Course",
      "description": "Learn the fundamentals of Next.js with this hands-on course.",
      "image": "https://picsum.photos/300/300?random=72",
      "authors": "David Garcia, Sophia Martinez, Jane Smith",
      "price": "83.99\u20AC",
      "paid": false,
      "language": [
        "French",
        "Spanish"
      ],
      "topic": "Next.js",
      "level": "Intermediate"
    },
    {
      "id": 73,
      "title": "Ultimate CSS Course",
      "description": "Get started with CSS and create your first application.",
      "image": "https://picsum.photos/300/300?random=73",
      "authors": "David Garcia",
      "price": "65.99\u20AC",
      "paid": true,
      "language": [
        "Spanish"
      ],
      "topic": "CSS",
      "level": "Intermediate"
    },
    {
      "id": 74,
      "title": "Comprehensive HTML Course",
      "description": "A deep dive into HTML to take your skills to the next level.",
      "image": "https://picsum.photos/300/300?random=74",
      "authors": "Sophia Martinez, Charlie Davis",
      "price": "129.99\u20AC",
      "paid": false,
      "language": [
        "French",
        "Italian",
        "English",
        "Spanish"
      ],
      "topic": "HTML",
      "level": "Expert"
    },
    {
      "id": 75,
      "title": "Comprehensive React Course",
      "description": "Get started with React and create your first application.",
      "image": "https://picsum.photos/300/300?random=75",
      "authors": "Emily White",
      "price": "174.99\u20AC",
      "paid": false,
      "language": [
        "English"
      ],
      "topic": "React",
      "level": "Beginner"
    },
    {
      "id": 76,
      "title": "Essential Node.js Course",
      "description": "Perfect your Node.js knowledge with interactive exercises and challenges.",
      "image": "https://picsum.photos/300/300?random=76",
      "authors": "Sophia Martinez, John Doe, Jane Smith",
      "price": "123.99\u20AC",
      "paid": true,
      "language": [
        "Italian"
      ],
      "topic": "Node.js",
      "level": "Beginner"
    },
    {
      "id": 77,
      "title": "Practical Javascript Course",
      "description": "Explore advanced concepts in Javascript and build amazing projects.",
      "image": "https://picsum.photos/300/300?random=77",
      "authors": "Jane Smith, Sophia Martinez, Charlie Davis",
      "price": "198.99\u20AC",
      "paid": true,
      "language": [
        "French",
        "Spanish",
        "German",
        "English",
        "Italian"
      ],
      "topic": "Javascript",
      "level": "Intermediate"
    },
    {
      "id": 78,
      "title": "Complete Next.js Course",
      "description": "A comprehensive guide to Next.js for Beginner developers.",
      "image": "https://picsum.photos/300/300?random=78",
      "authors": "Alice Johnson, John Doe",
      "price": "168.99\u20AC",
      "paid": false,
      "language": [
        "French",
        "German"
      ],
      "topic": "Next.js",
      "level": "Intermediate"
    },
    {
      "id": 79,
      "title": "Practical Javascript Course",
      "description": "Perfect your Javascript knowledge with interactive exercises and challenges.",
      "image": "https://picsum.photos/300/300?random=79",
      "authors": "Charlie Davis",
      "price": "49.99\u20AC",
      "paid": false,
      "language": [
        "Italian",
        "German",
        "English",
        "Spanish"
      ],
      "topic": "Javascript",
      "level": "Beginner"
    },
    {
      "id": 80,
      "title": "Practical Javascript Course",
      "description": "Perfect your Javascript knowledge with interactive exercises and challenges.",
      "image": "https://picsum.photos/300/300?random=80",
      "authors": "Emily White, Sophia Martinez, Bob Brown",
      "price": "147.99\u20AC",
      "paid": false,
      "language": [
        "German",
        "English",
        "Italian",
        "French"
      ],
      "topic": "Javascript",
      "level": "Beginner"
    },
    {
      "id": 81,
      "title": "Ultimate CSS Course",
      "description": "A deep dive into CSS to take your skills to the next level.",
      "image": "https://picsum.photos/300/300?random=81",
      "authors": "Alice Johnson, David Garcia, Charlie Davis",
      "price": "148.99\u20AC",
      "paid": false,
      "language": [
        "English",
        "French",
        "Spanish",
        "Italian"
      ],
      "topic": "CSS",
      "level": "Beginner"
    },
    {
      "id": 82,
      "title": "Advanced Javascript Course",
      "description": "Boost your coding skills with this Beginner Javascript course.",
      "image": "https://picsum.photos/300/300?random=82",
      "authors": "Emily White, David Garcia, Bob Brown",
      "price": "82.99\u20AC",
      "paid": false,
      "language": [
        "English",
        "Italian",
        "French"
      ],
      "topic": "Javascript",
      "level": "Intermediate"
    },
    {
      "id": 83,
      "title": "Comprehensive React Course",
      "description": "Master React with real-world projects and expert guidance.",
      "image": "https://picsum.photos/300/300?random=83",
      "authors": "Sophia Martinez",
      "price": "137.99\u20AC",
      "paid": false,
      "language": [
        "Spanish",
        "Italian"
      ],
      "topic": "React",
      "level": "Expert"
    },
    {
      "id": 84,
      "title": "Practical React Course",
      "description": "Boost your coding skills with this Intermediate React course.",
      "image": "https://picsum.photos/300/300?random=84",
      "authors": "Sophia Martinez, David Garcia, Bob Brown",
      "price": "31.99\u20AC",
      "paid": true,
      "language": [
        "French"
      ],
      "topic": "React",
      "level": "Intermediate"
    },
    {
      "id": 85,
      "title": "Practical React Course",
      "description": "Unlock the full potential of React with this extensive course.",
      "image": "https://picsum.photos/300/300?random=85",
      "authors": "Bob Brown",
      "price": "139.99\u20AC",
      "paid": false,
      "language": [
        "English",
        "Spanish"
      ],
      "topic": "React",
      "level": "Beginner"
    },
    {
      "id": 86,
      "title": "Ultimate Node.js Course",
      "description": "A deep dive into Node.js to take your skills to the next level.",
      "image": "https://picsum.photos/300/300?random=86",
      "authors": "John Doe, Sophia Martinez",
      "price": "186.99\u20AC",
      "paid": false,
      "language": [
        "Italian",
        "French"
      ],
      "topic": "Node.js",
      "level": "Beginner"
    },
    {
      "id": 87,
      "title": "Complete CSS Course",
      "description": "Explore advanced concepts in CSS and build amazing projects.",
      "image": "https://picsum.photos/300/300?random=87",
      "authors": "Emily White, Charlie Davis, Jane Smith",
      "price": "93.99\u20AC",
      "paid": true,
      "language": [
        "French"
      ],
      "topic": "CSS",
      "level": "Expert"
    },
    {
      "id": 88,
      "title": "Complete Next.js Course",
      "description": "Boost your coding skills with this Intermediate Next.js course.",
      "image": "https://picsum.photos/300/300?random=88",
      "authors": "Jane Smith",
      "price": "100.99\u20AC",
      "paid": false,
      "language": [
        "Italian",
        "Spanish",
        "German",
        "English"
      ],
      "topic": "Next.js",
      "level": "Expert"
    },
    {
      "id": 89,
      "title": "Practical CSS Course",
      "description": "Perfect your CSS knowledge with interactive exercises and challenges.",
      "image": "https://picsum.photos/300/300?random=89",
      "authors": "Sophia Martinez, David Garcia",
      "price": "89.99\u20AC",
      "paid": true,
      "language": [
        "French",
        "English",
        "Spanish",
        "German",
        "Italian"
      ],
      "topic": "CSS",
      "level": "Intermediate"
    },
    {
      "id": 90,
      "title": "Complete CSS Course",
      "description": "Boost your coding skills with this Beginner CSS course.",
      "image": "https://picsum.photos/300/300?random=90",
      "authors": "Sophia Martinez",
      "price": "115.99\u20AC",
      "paid": true,
      "language": [
        "Spanish",
        "German",
        "French",
        "English"
      ],
      "topic": "CSS",
      "level": "Beginner"
    },
    {
      "id": 91,
      "title": "Advanced Javascript Course",
      "description": "Master Javascript with real-world projects and expert guidance.",
      "image": "https://picsum.photos/300/300?random=91",
      "authors": "Bob Brown, Alice Johnson",
      "price": "73.99\u20AC",
      "paid": true,
      "language": [
        "Spanish"
      ],
      "topic": "Javascript",
      "level": "Expert"
    },
    {
      "id": 92,
      "title": "Essential Node.js Course",
      "description": "Step-by-step instructions to become proficient in Node.js.",
      "image": "https://picsum.photos/300/300?random=92",
      "authors": "Bob Brown",
      "price": "200.99\u20AC",
      "paid": false,
      "language": [
        "German",
        "Italian"
      ],
      "topic": "Node.js",
      "level": "Intermediate"
    },
    {
      "id": 93,
      "title": "Essential Javascript Course",
      "description": "Unlock the full potential of Javascript with this extensive course.",
      "image": "https://picsum.photos/300/300?random=93",
      "authors": "Emily White, John Doe",
      "price": "180.99\u20AC",
      "paid": false,
      "language": [
        "Italian",
        "Spanish"
      ],
      "topic": "Javascript",
      "level": "Intermediate"
    },
    {
      "id": 94,
      "title": "Advanced Javascript Course",
      "description": "Step-by-step instructions to become proficient in Javascript.",
      "image": "https://picsum.photos/300/300?random=94",
      "authors": "Charlie Davis, John Doe",
      "price": "177.99\u20AC",
      "paid": false,
      "language": [
        "Spanish",
        "English"
      ],
      "topic": "Javascript",
      "level": "Intermediate"
    },
    {
      "id": 95,
      "title": "Advanced Next.js Course",
      "description": "Learn the fundamentals of Next.js with this hands-on course.",
      "image": "https://picsum.photos/300/300?random=95",
      "authors": "Alice Johnson, Sophia Martinez",
      "price": "155.99\u20AC",
      "paid": false,
      "language": [
        "Italian",
        "English",
        "French"
      ],
      "topic": "Next.js",
      "level": "Beginner"
    },
    {
      "id": 96,
      "title": "Essential HTML Course",
      "description": "A comprehensive guide to HTML for Expert developers.",
      "image": "https://picsum.photos/300/300?random=96",
      "authors": "Bob Brown, Sophia Martinez",
      "price": "77.99\u20AC",
      "paid": false,
      "language": [
        "French",
        "German",
        "Italian",
        "English"
      ],
      "topic": "HTML",
      "level": "Intermediate"
    },
    {
      "id": 97,
      "title": "Advanced Node.js Course",
      "description": "Step-by-step instructions to become proficient in Node.js.",
      "image": "https://picsum.photos/300/300?random=97",
      "authors": "Emily White, David Garcia",
      "price": "188.99\u20AC",
      "paid": true,
      "language": [
        "Spanish",
        "Italian",
        "French",
        "German"
      ],
      "topic": "Node.js",
      "level": "Beginner"
    },
    {
      "id": 98,
      "title": "Practical HTML Course",
      "description": "A deep dive into HTML to take your skills to the next level.",
      "image": "https://picsum.photos/300/300?random=98",
      "authors": "Charlie Davis, Bob Brown, Emily White",
      "price": "109.99\u20AC",
      "paid": false,
      "language": [
        "English",
        "Italian",
        "Spanish",
        "German"
      ],
      "topic": "HTML",
      "level": "Intermediate"
    },
    {
      "id": 99,
      "title": "Practical Node.js Course",
      "description": "Explore advanced concepts in Node.js and build amazing projects.",
      "image": "https://picsum.photos/300/300?random=99",
      "authors": "Emily White, Jane Smith",
      "price": "142.99\u20AC",
      "paid": false,
      "language": [
        "Spanish",
        "German",
        "French",
        "Italian"
      ],
      "topic": "Node.js",
      "level": "Intermediate"
    },
    {
      "id": 100,
      "title": "Ultimate Javascript Course",
      "description": "Learn the fundamentals of Javascript with this hands-on course.",
      "image": "https://picsum.photos/300/300?random=100",
      "authors": "Charlie Davis",
      "price": "40.99\u20AC",
      "paid": true,
      "language": [
        "German"
      ],
      "topic": "Javascript",
      "level": "Intermediate"
    }
  ];
  var data_default = data;

  // node_modules/ssr-window/ssr-window.esm.js
  function isObject(obj) {
    return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
  }
  function extend(target = {}, src = {}) {
    Object.keys(src).forEach((key) => {
      if (typeof target[key] === "undefined")
        target[key] = src[key];
      else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
        extend(target[key], src[key]);
      }
    });
  }
  var ssrDocument = {
    body: {},
    addEventListener() {
    },
    removeEventListener() {
    },
    activeElement: {
      blur() {
      },
      nodeName: ""
    },
    querySelector() {
      return null;
    },
    querySelectorAll() {
      return [];
    },
    getElementById() {
      return null;
    },
    createEvent() {
      return {
        initEvent() {
        }
      };
    },
    createElement() {
      return {
        children: [],
        childNodes: [],
        style: {},
        setAttribute() {
        },
        getElementsByTagName() {
          return [];
        }
      };
    },
    createElementNS() {
      return {};
    },
    importNode() {
      return null;
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    }
  };
  function getDocument() {
    const doc = typeof document !== "undefined" ? document : {};
    extend(doc, ssrDocument);
    return doc;
  }
  var ssrWindow = {
    document: ssrDocument,
    navigator: {
      userAgent: ""
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    },
    history: {
      replaceState() {
      },
      pushState() {
      },
      go() {
      },
      back() {
      }
    },
    CustomEvent: function CustomEvent() {
      return this;
    },
    addEventListener() {
    },
    removeEventListener() {
    },
    getComputedStyle() {
      return {
        getPropertyValue() {
          return "";
        }
      };
    },
    Image() {
    },
    Date() {
    },
    screen: {},
    setTimeout() {
    },
    clearTimeout() {
    },
    matchMedia() {
      return {};
    },
    requestAnimationFrame(callback) {
      if (typeof setTimeout === "undefined") {
        callback();
        return null;
      }
      return setTimeout(callback, 0);
    },
    cancelAnimationFrame(id) {
      if (typeof setTimeout === "undefined") {
        return;
      }
      clearTimeout(id);
    }
  };
  function getWindow() {
    const win = typeof window !== "undefined" ? window : {};
    extend(win, ssrWindow);
    return win;
  }

  // node_modules/dom7/dom7.esm.js
  function makeReactive(obj) {
    const proto = obj.__proto__;
    Object.defineProperty(obj, "__proto__", {
      get() {
        return proto;
      },
      set(value) {
        proto.__proto__ = value;
      }
    });
  }
  var Dom7 = class extends Array {
    constructor(items) {
      if (typeof items === "number") {
        super(items);
      } else {
        super(...items || []);
        makeReactive(this);
      }
    }
  };
  function arrayFlat(arr = []) {
    const res = [];
    arr.forEach((el) => {
      if (Array.isArray(el)) {
        res.push(...arrayFlat(el));
      } else {
        res.push(el);
      }
    });
    return res;
  }
  function arrayFilter(arr, callback) {
    return Array.prototype.filter.call(arr, callback);
  }
  function arrayUnique(arr) {
    const uniqueArray = [];
    for (let i = 0; i < arr.length; i += 1) {
      if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
    }
    return uniqueArray;
  }
  function qsa(selector, context) {
    if (typeof selector !== "string") {
      return [selector];
    }
    const a = [];
    const res = context.querySelectorAll(selector);
    for (let i = 0; i < res.length; i += 1) {
      a.push(res[i]);
    }
    return a;
  }
  function $(selector, context) {
    const window2 = getWindow();
    const document2 = getDocument();
    let arr = [];
    if (!context && selector instanceof Dom7) {
      return selector;
    }
    if (!selector) {
      return new Dom7(arr);
    }
    if (typeof selector === "string") {
      const html2 = selector.trim();
      if (html2.indexOf("<") >= 0 && html2.indexOf(">") >= 0) {
        let toCreate = "div";
        if (html2.indexOf("<li") === 0) toCreate = "ul";
        if (html2.indexOf("<tr") === 0) toCreate = "tbody";
        if (html2.indexOf("<td") === 0 || html2.indexOf("<th") === 0) toCreate = "tr";
        if (html2.indexOf("<tbody") === 0) toCreate = "table";
        if (html2.indexOf("<option") === 0) toCreate = "select";
        const tempParent = document2.createElement(toCreate);
        tempParent.innerHTML = html2;
        for (let i = 0; i < tempParent.childNodes.length; i += 1) {
          arr.push(tempParent.childNodes[i]);
        }
      } else {
        arr = qsa(selector.trim(), context || document2);
      }
    } else if (selector.nodeType || selector === window2 || selector === document2) {
      arr.push(selector);
    } else if (Array.isArray(selector)) {
      if (selector instanceof Dom7) return selector;
      arr = selector;
    }
    return new Dom7(arrayUnique(arr));
  }
  $.fn = Dom7.prototype;
  function addClass(...classes) {
    const classNames = arrayFlat(classes.map((c) => c.split(" ")));
    this.forEach((el) => {
      el.classList.add(...classNames);
    });
    return this;
  }
  function removeClass(...classes) {
    const classNames = arrayFlat(classes.map((c) => c.split(" ")));
    this.forEach((el) => {
      el.classList.remove(...classNames);
    });
    return this;
  }
  function toggleClass(...classes) {
    const classNames = arrayFlat(classes.map((c) => c.split(" ")));
    this.forEach((el) => {
      classNames.forEach((className) => {
        el.classList.toggle(className);
      });
    });
  }
  function hasClass(...classes) {
    const classNames = arrayFlat(classes.map((c) => c.split(" ")));
    return arrayFilter(this, (el) => {
      return classNames.filter((className) => el.classList.contains(className)).length > 0;
    }).length > 0;
  }
  function attr(attrs, value) {
    if (arguments.length === 1 && typeof attrs === "string") {
      if (this[0]) return this[0].getAttribute(attrs);
      return void 0;
    }
    for (let i = 0; i < this.length; i += 1) {
      if (arguments.length === 2) {
        this[i].setAttribute(attrs, value);
      } else {
        for (const attrName in attrs) {
          this[i][attrName] = attrs[attrName];
          this[i].setAttribute(attrName, attrs[attrName]);
        }
      }
    }
    return this;
  }
  function removeAttr(attr2) {
    for (let i = 0; i < this.length; i += 1) {
      this[i].removeAttribute(attr2);
    }
    return this;
  }
  function transform(transform2) {
    for (let i = 0; i < this.length; i += 1) {
      this[i].style.transform = transform2;
    }
    return this;
  }
  function transition(duration) {
    for (let i = 0; i < this.length; i += 1) {
      this[i].style.transitionDuration = typeof duration !== "string" ? `${duration}ms` : duration;
    }
    return this;
  }
  function on(...args) {
    let [eventType, targetSelector, listener, capture] = args;
    if (typeof args[1] === "function") {
      [eventType, listener, capture] = args;
      targetSelector = void 0;
    }
    if (!capture) capture = false;
    function handleLiveEvent(e) {
      const target = e.target;
      if (!target) return;
      const eventData = e.target.dom7EventData || [];
      if (eventData.indexOf(e) < 0) {
        eventData.unshift(e);
      }
      if ($(target).is(targetSelector)) listener.apply(target, eventData);
      else {
        const parents2 = $(target).parents();
        for (let k = 0; k < parents2.length; k += 1) {
          if ($(parents2[k]).is(targetSelector)) listener.apply(parents2[k], eventData);
        }
      }
    }
    function handleEvent(e) {
      const eventData = e && e.target ? e.target.dom7EventData || [] : [];
      if (eventData.indexOf(e) < 0) {
        eventData.unshift(e);
      }
      listener.apply(this, eventData);
    }
    const events2 = eventType.split(" ");
    let j;
    for (let i = 0; i < this.length; i += 1) {
      const el = this[i];
      if (!targetSelector) {
        for (j = 0; j < events2.length; j += 1) {
          const event2 = events2[j];
          if (!el.dom7Listeners) el.dom7Listeners = {};
          if (!el.dom7Listeners[event2]) el.dom7Listeners[event2] = [];
          el.dom7Listeners[event2].push({
            listener,
            proxyListener: handleEvent
          });
          el.addEventListener(event2, handleEvent, capture);
        }
      } else {
        for (j = 0; j < events2.length; j += 1) {
          const event2 = events2[j];
          if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
          if (!el.dom7LiveListeners[event2]) el.dom7LiveListeners[event2] = [];
          el.dom7LiveListeners[event2].push({
            listener,
            proxyListener: handleLiveEvent
          });
          el.addEventListener(event2, handleLiveEvent, capture);
        }
      }
    }
    return this;
  }
  function off(...args) {
    let [eventType, targetSelector, listener, capture] = args;
    if (typeof args[1] === "function") {
      [eventType, listener, capture] = args;
      targetSelector = void 0;
    }
    if (!capture) capture = false;
    const events2 = eventType.split(" ");
    for (let i = 0; i < events2.length; i += 1) {
      const event2 = events2[i];
      for (let j = 0; j < this.length; j += 1) {
        const el = this[j];
        let handlers;
        if (!targetSelector && el.dom7Listeners) {
          handlers = el.dom7Listeners[event2];
        } else if (targetSelector && el.dom7LiveListeners) {
          handlers = el.dom7LiveListeners[event2];
        }
        if (handlers && handlers.length) {
          for (let k = handlers.length - 1; k >= 0; k -= 1) {
            const handler = handlers[k];
            if (listener && handler.listener === listener) {
              el.removeEventListener(event2, handler.proxyListener, capture);
              handlers.splice(k, 1);
            } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
              el.removeEventListener(event2, handler.proxyListener, capture);
              handlers.splice(k, 1);
            } else if (!listener) {
              el.removeEventListener(event2, handler.proxyListener, capture);
              handlers.splice(k, 1);
            }
          }
        }
      }
    }
    return this;
  }
  function trigger(...args) {
    const window2 = getWindow();
    const events2 = args[0].split(" ");
    const eventData = args[1];
    for (let i = 0; i < events2.length; i += 1) {
      const event2 = events2[i];
      for (let j = 0; j < this.length; j += 1) {
        const el = this[j];
        if (window2.CustomEvent) {
          const evt = new window2.CustomEvent(event2, {
            detail: eventData,
            bubbles: true,
            cancelable: true
          });
          el.dom7EventData = args.filter((data2, dataIndex) => dataIndex > 0);
          el.dispatchEvent(evt);
          el.dom7EventData = [];
          delete el.dom7EventData;
        }
      }
    }
    return this;
  }
  function transitionEnd(callback) {
    const dom = this;
    function fireCallBack(e) {
      if (e.target !== this) return;
      callback.call(this, e);
      dom.off("transitionend", fireCallBack);
    }
    if (callback) {
      dom.on("transitionend", fireCallBack);
    }
    return this;
  }
  function outerWidth(includeMargins) {
    if (this.length > 0) {
      if (includeMargins) {
        const styles2 = this.styles();
        return this[0].offsetWidth + parseFloat(styles2.getPropertyValue("margin-right")) + parseFloat(styles2.getPropertyValue("margin-left"));
      }
      return this[0].offsetWidth;
    }
    return null;
  }
  function outerHeight(includeMargins) {
    if (this.length > 0) {
      if (includeMargins) {
        const styles2 = this.styles();
        return this[0].offsetHeight + parseFloat(styles2.getPropertyValue("margin-top")) + parseFloat(styles2.getPropertyValue("margin-bottom"));
      }
      return this[0].offsetHeight;
    }
    return null;
  }
  function offset() {
    if (this.length > 0) {
      const window2 = getWindow();
      const document2 = getDocument();
      const el = this[0];
      const box = el.getBoundingClientRect();
      const body = document2.body;
      const clientTop = el.clientTop || body.clientTop || 0;
      const clientLeft = el.clientLeft || body.clientLeft || 0;
      const scrollTop = el === window2 ? window2.scrollY : el.scrollTop;
      const scrollLeft = el === window2 ? window2.scrollX : el.scrollLeft;
      return {
        top: box.top + scrollTop - clientTop,
        left: box.left + scrollLeft - clientLeft
      };
    }
    return null;
  }
  function styles() {
    const window2 = getWindow();
    if (this[0]) return window2.getComputedStyle(this[0], null);
    return {};
  }
  function css(props, value) {
    const window2 = getWindow();
    let i;
    if (arguments.length === 1) {
      if (typeof props === "string") {
        if (this[0]) return window2.getComputedStyle(this[0], null).getPropertyValue(props);
      } else {
        for (i = 0; i < this.length; i += 1) {
          for (const prop in props) {
            this[i].style[prop] = props[prop];
          }
        }
        return this;
      }
    }
    if (arguments.length === 2 && typeof props === "string") {
      for (i = 0; i < this.length; i += 1) {
        this[i].style[props] = value;
      }
      return this;
    }
    return this;
  }
  function each(callback) {
    if (!callback) return this;
    this.forEach((el, index2) => {
      callback.apply(el, [el, index2]);
    });
    return this;
  }
  function filter(callback) {
    const result2 = arrayFilter(this, callback);
    return $(result2);
  }
  function html(html2) {
    if (typeof html2 === "undefined") {
      return this[0] ? this[0].innerHTML : null;
    }
    for (let i = 0; i < this.length; i += 1) {
      this[i].innerHTML = html2;
    }
    return this;
  }
  function text(text2) {
    if (typeof text2 === "undefined") {
      return this[0] ? this[0].textContent.trim() : null;
    }
    for (let i = 0; i < this.length; i += 1) {
      this[i].textContent = text2;
    }
    return this;
  }
  function is(selector) {
    const window2 = getWindow();
    const document2 = getDocument();
    const el = this[0];
    let compareWith;
    let i;
    if (!el || typeof selector === "undefined") return false;
    if (typeof selector === "string") {
      if (el.matches) return el.matches(selector);
      if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
      if (el.msMatchesSelector) return el.msMatchesSelector(selector);
      compareWith = $(selector);
      for (i = 0; i < compareWith.length; i += 1) {
        if (compareWith[i] === el) return true;
      }
      return false;
    }
    if (selector === document2) {
      return el === document2;
    }
    if (selector === window2) {
      return el === window2;
    }
    if (selector.nodeType || selector instanceof Dom7) {
      compareWith = selector.nodeType ? [selector] : selector;
      for (i = 0; i < compareWith.length; i += 1) {
        if (compareWith[i] === el) return true;
      }
      return false;
    }
    return false;
  }
  function index() {
    let child = this[0];
    let i;
    if (child) {
      i = 0;
      while ((child = child.previousSibling) !== null) {
        if (child.nodeType === 1) i += 1;
      }
      return i;
    }
    return void 0;
  }
  function eq(index2) {
    if (typeof index2 === "undefined") return this;
    const length = this.length;
    if (index2 > length - 1) {
      return $([]);
    }
    if (index2 < 0) {
      const returnIndex = length + index2;
      if (returnIndex < 0) return $([]);
      return $([this[returnIndex]]);
    }
    return $([this[index2]]);
  }
  function append(...els) {
    let newChild;
    const document2 = getDocument();
    for (let k = 0; k < els.length; k += 1) {
      newChild = els[k];
      for (let i = 0; i < this.length; i += 1) {
        if (typeof newChild === "string") {
          const tempDiv = document2.createElement("div");
          tempDiv.innerHTML = newChild;
          while (tempDiv.firstChild) {
            this[i].appendChild(tempDiv.firstChild);
          }
        } else if (newChild instanceof Dom7) {
          for (let j = 0; j < newChild.length; j += 1) {
            this[i].appendChild(newChild[j]);
          }
        } else {
          this[i].appendChild(newChild);
        }
      }
    }
    return this;
  }
  function prepend(newChild) {
    const document2 = getDocument();
    let i;
    let j;
    for (i = 0; i < this.length; i += 1) {
      if (typeof newChild === "string") {
        const tempDiv = document2.createElement("div");
        tempDiv.innerHTML = newChild;
        for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
          this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
        }
      } else if (newChild instanceof Dom7) {
        for (j = 0; j < newChild.length; j += 1) {
          this[i].insertBefore(newChild[j], this[i].childNodes[0]);
        }
      } else {
        this[i].insertBefore(newChild, this[i].childNodes[0]);
      }
    }
    return this;
  }
  function next(selector) {
    if (this.length > 0) {
      if (selector) {
        if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
          return $([this[0].nextElementSibling]);
        }
        return $([]);
      }
      if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
      return $([]);
    }
    return $([]);
  }
  function nextAll(selector) {
    const nextEls = [];
    let el = this[0];
    if (!el) return $([]);
    while (el.nextElementSibling) {
      const next2 = el.nextElementSibling;
      if (selector) {
        if ($(next2).is(selector)) nextEls.push(next2);
      } else nextEls.push(next2);
      el = next2;
    }
    return $(nextEls);
  }
  function prev(selector) {
    if (this.length > 0) {
      const el = this[0];
      if (selector) {
        if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
          return $([el.previousElementSibling]);
        }
        return $([]);
      }
      if (el.previousElementSibling) return $([el.previousElementSibling]);
      return $([]);
    }
    return $([]);
  }
  function prevAll(selector) {
    const prevEls = [];
    let el = this[0];
    if (!el) return $([]);
    while (el.previousElementSibling) {
      const prev2 = el.previousElementSibling;
      if (selector) {
        if ($(prev2).is(selector)) prevEls.push(prev2);
      } else prevEls.push(prev2);
      el = prev2;
    }
    return $(prevEls);
  }
  function parent(selector) {
    const parents2 = [];
    for (let i = 0; i < this.length; i += 1) {
      if (this[i].parentNode !== null) {
        if (selector) {
          if ($(this[i].parentNode).is(selector)) parents2.push(this[i].parentNode);
        } else {
          parents2.push(this[i].parentNode);
        }
      }
    }
    return $(parents2);
  }
  function parents(selector) {
    const parents2 = [];
    for (let i = 0; i < this.length; i += 1) {
      let parent2 = this[i].parentNode;
      while (parent2) {
        if (selector) {
          if ($(parent2).is(selector)) parents2.push(parent2);
        } else {
          parents2.push(parent2);
        }
        parent2 = parent2.parentNode;
      }
    }
    return $(parents2);
  }
  function closest(selector) {
    let closest2 = this;
    if (typeof selector === "undefined") {
      return $([]);
    }
    if (!closest2.is(selector)) {
      closest2 = closest2.parents(selector).eq(0);
    }
    return closest2;
  }
  function find(selector) {
    const foundElements = [];
    for (let i = 0; i < this.length; i += 1) {
      const found = this[i].querySelectorAll(selector);
      for (let j = 0; j < found.length; j += 1) {
        foundElements.push(found[j]);
      }
    }
    return $(foundElements);
  }
  function children(selector) {
    const children2 = [];
    for (let i = 0; i < this.length; i += 1) {
      const childNodes = this[i].children;
      for (let j = 0; j < childNodes.length; j += 1) {
        if (!selector || $(childNodes[j]).is(selector)) {
          children2.push(childNodes[j]);
        }
      }
    }
    return $(children2);
  }
  function remove() {
    for (let i = 0; i < this.length; i += 1) {
      if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
    }
    return this;
  }
  var noTrigger = "resize scroll".split(" ");
  function shortcut(name) {
    function eventHandler(...args) {
      if (typeof args[0] === "undefined") {
        for (let i = 0; i < this.length; i += 1) {
          if (noTrigger.indexOf(name) < 0) {
            if (name in this[i]) this[i][name]();
            else {
              $(this[i]).trigger(name);
            }
          }
        }
        return this;
      }
      return this.on(name, ...args);
    }
    return eventHandler;
  }
  var click = shortcut("click");
  var blur = shortcut("blur");
  var focus = shortcut("focus");
  var focusin = shortcut("focusin");
  var focusout = shortcut("focusout");
  var keyup = shortcut("keyup");
  var keydown = shortcut("keydown");
  var keypress = shortcut("keypress");
  var submit = shortcut("submit");
  var change = shortcut("change");
  var mousedown = shortcut("mousedown");
  var mousemove = shortcut("mousemove");
  var mouseup = shortcut("mouseup");
  var mouseenter = shortcut("mouseenter");
  var mouseleave = shortcut("mouseleave");
  var mouseout = shortcut("mouseout");
  var mouseover = shortcut("mouseover");
  var touchstart = shortcut("touchstart");
  var touchend = shortcut("touchend");
  var touchmove = shortcut("touchmove");
  var resize = shortcut("resize");
  var scroll = shortcut("scroll");

  // node_modules/swiper/shared/dom.js
  var Methods = {
    addClass,
    removeClass,
    hasClass,
    toggleClass,
    attr,
    removeAttr,
    transform,
    transition,
    on,
    off,
    trigger,
    transitionEnd,
    outerWidth,
    outerHeight,
    styles,
    offset,
    css,
    each,
    html,
    text,
    is,
    index,
    eq,
    append,
    prepend,
    next,
    nextAll,
    prev,
    prevAll,
    parent,
    parents,
    closest,
    find,
    children,
    filter,
    remove
  };
  Object.keys(Methods).forEach((methodName) => {
    Object.defineProperty($.fn, methodName, {
      value: Methods[methodName],
      writable: true
    });
  });
  var dom_default = $;

  // node_modules/swiper/shared/utils.js
  function deleteProps(obj) {
    const object = obj;
    Object.keys(object).forEach((key) => {
      try {
        object[key] = null;
      } catch (e) {
      }
      try {
        delete object[key];
      } catch (e) {
      }
    });
  }
  function nextTick(callback, delay = 0) {
    return setTimeout(callback, delay);
  }
  function now() {
    return Date.now();
  }
  function getComputedStyle2(el) {
    const window2 = getWindow();
    let style;
    if (window2.getComputedStyle) {
      style = window2.getComputedStyle(el, null);
    }
    if (!style && el.currentStyle) {
      style = el.currentStyle;
    }
    if (!style) {
      style = el.style;
    }
    return style;
  }
  function getTranslate(el, axis = "x") {
    const window2 = getWindow();
    let matrix;
    let curTransform;
    let transformMatrix;
    const curStyle = getComputedStyle2(el, null);
    if (window2.WebKitCSSMatrix) {
      curTransform = curStyle.transform || curStyle.webkitTransform;
      if (curTransform.split(",").length > 6) {
        curTransform = curTransform.split(", ").map((a) => a.replace(",", ".")).join(", ");
      }
      transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
    } else {
      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
      matrix = transformMatrix.toString().split(",");
    }
    if (axis === "x") {
      if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m41;
      else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
      else curTransform = parseFloat(matrix[4]);
    }
    if (axis === "y") {
      if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m42;
      else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
      else curTransform = parseFloat(matrix[5]);
    }
    return curTransform || 0;
  }
  function isObject2(o) {
    return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object";
  }
  function isNode(node) {
    if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") {
      return node instanceof HTMLElement;
    }
    return node && (node.nodeType === 1 || node.nodeType === 11);
  }
  function extend2(...args) {
    const to = Object(args[0]);
    const noExtend = ["__proto__", "constructor", "prototype"];
    for (let i = 1; i < args.length; i += 1) {
      const nextSource = args[i];
      if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
        const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);
        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== void 0 && desc.enumerable) {
            if (isObject2(to[nextKey]) && isObject2(nextSource[nextKey])) {
              if (nextSource[nextKey].__swiper__) {
                to[nextKey] = nextSource[nextKey];
              } else {
                extend2(to[nextKey], nextSource[nextKey]);
              }
            } else if (!isObject2(to[nextKey]) && isObject2(nextSource[nextKey])) {
              to[nextKey] = {};
              if (nextSource[nextKey].__swiper__) {
                to[nextKey] = nextSource[nextKey];
              } else {
                extend2(to[nextKey], nextSource[nextKey]);
              }
            } else {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
    }
    return to;
  }
  function setCSSProperty(el, varName, varValue) {
    el.style.setProperty(varName, varValue);
  }
  function animateCSSModeScroll({
    swiper: swiper2,
    targetPosition,
    side
  }) {
    const window2 = getWindow();
    const startPosition = -swiper2.translate;
    let startTime = null;
    let time;
    const duration = swiper2.params.speed;
    swiper2.wrapperEl.style.scrollSnapType = "none";
    window2.cancelAnimationFrame(swiper2.cssModeFrameID);
    const dir = targetPosition > startPosition ? "next" : "prev";
    const isOutOfBound = (current, target) => {
      return dir === "next" && current >= target || dir === "prev" && current <= target;
    };
    const animate = () => {
      time = (/* @__PURE__ */ new Date()).getTime();
      if (startTime === null) {
        startTime = time;
      }
      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
      let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
      if (isOutOfBound(currentPosition, targetPosition)) {
        currentPosition = targetPosition;
      }
      swiper2.wrapperEl.scrollTo({
        [side]: currentPosition
      });
      if (isOutOfBound(currentPosition, targetPosition)) {
        swiper2.wrapperEl.style.overflow = "hidden";
        swiper2.wrapperEl.style.scrollSnapType = "";
        setTimeout(() => {
          swiper2.wrapperEl.style.overflow = "";
          swiper2.wrapperEl.scrollTo({
            [side]: currentPosition
          });
        });
        window2.cancelAnimationFrame(swiper2.cssModeFrameID);
        return;
      }
      swiper2.cssModeFrameID = window2.requestAnimationFrame(animate);
    };
    animate();
  }

  // node_modules/swiper/shared/get-support.js
  var support;
  function calcSupport() {
    const window2 = getWindow();
    const document2 = getDocument();
    return {
      smoothScroll: document2.documentElement && "scrollBehavior" in document2.documentElement.style,
      touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch),
      passiveListener: function checkPassiveListener() {
        let supportsPassive = false;
        try {
          const opts = Object.defineProperty({}, "passive", {
            // eslint-disable-next-line
            get() {
              supportsPassive = true;
            }
          });
          window2.addEventListener("testPassiveListener", null, opts);
        } catch (e) {
        }
        return supportsPassive;
      }(),
      gestures: function checkGestures() {
        return "ongesturestart" in window2;
      }()
    };
  }
  function getSupport() {
    if (!support) {
      support = calcSupport();
    }
    return support;
  }

  // node_modules/swiper/shared/get-device.js
  var deviceCached;
  function calcDevice({
    userAgent
  } = {}) {
    const support2 = getSupport();
    const window2 = getWindow();
    const platform = window2.navigator.platform;
    const ua = userAgent || window2.navigator.userAgent;
    const device = {
      ios: false,
      android: false
    };
    const screenWidth = window2.screen.width;
    const screenHeight = window2.screen.height;
    const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
    let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
    const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
    const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
    const windows = platform === "Win32";
    let macos = platform === "MacIntel";
    const iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
    if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
      ipad = ua.match(/(Version)\/([\d.]+)/);
      if (!ipad) ipad = [0, 1, "13_0_0"];
      macos = false;
    }
    if (android && !windows) {
      device.os = "android";
      device.android = true;
    }
    if (ipad || iphone || ipod) {
      device.os = "ios";
      device.ios = true;
    }
    return device;
  }
  function getDevice(overrides = {}) {
    if (!deviceCached) {
      deviceCached = calcDevice(overrides);
    }
    return deviceCached;
  }

  // node_modules/swiper/shared/get-browser.js
  var browser;
  function calcBrowser() {
    const window2 = getWindow();
    function isSafari() {
      const ua = window2.navigator.userAgent.toLowerCase();
      return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
    }
    return {
      isSafari: isSafari(),
      isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent)
    };
  }
  function getBrowser() {
    if (!browser) {
      browser = calcBrowser();
    }
    return browser;
  }

  // node_modules/swiper/core/modules/resize/resize.js
  function Resize({
    swiper: swiper2,
    on: on2,
    emit
  }) {
    const window2 = getWindow();
    let observer = null;
    let animationFrame = null;
    const resizeHandler = () => {
      if (!swiper2 || swiper2.destroyed || !swiper2.initialized) return;
      emit("beforeResize");
      emit("resize");
    };
    const createObserver = () => {
      if (!swiper2 || swiper2.destroyed || !swiper2.initialized) return;
      observer = new ResizeObserver((entries) => {
        animationFrame = window2.requestAnimationFrame(() => {
          const {
            width,
            height
          } = swiper2;
          let newWidth = width;
          let newHeight = height;
          entries.forEach(({
            contentBoxSize,
            contentRect,
            target
          }) => {
            if (target && target !== swiper2.el) return;
            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
          });
          if (newWidth !== width || newHeight !== height) {
            resizeHandler();
          }
        });
      });
      observer.observe(swiper2.el);
    };
    const removeObserver = () => {
      if (animationFrame) {
        window2.cancelAnimationFrame(animationFrame);
      }
      if (observer && observer.unobserve && swiper2.el) {
        observer.unobserve(swiper2.el);
        observer = null;
      }
    };
    const orientationChangeHandler = () => {
      if (!swiper2 || swiper2.destroyed || !swiper2.initialized) return;
      emit("orientationchange");
    };
    on2("init", () => {
      if (swiper2.params.resizeObserver && typeof window2.ResizeObserver !== "undefined") {
        createObserver();
        return;
      }
      window2.addEventListener("resize", resizeHandler);
      window2.addEventListener("orientationchange", orientationChangeHandler);
    });
    on2("destroy", () => {
      removeObserver();
      window2.removeEventListener("resize", resizeHandler);
      window2.removeEventListener("orientationchange", orientationChangeHandler);
    });
  }

  // node_modules/swiper/core/modules/observer/observer.js
  function Observer({
    swiper: swiper2,
    extendParams,
    on: on2,
    emit
  }) {
    const observers = [];
    const window2 = getWindow();
    const attach = (target, options = {}) => {
      const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
      const observer = new ObserverFunc((mutations) => {
        if (mutations.length === 1) {
          emit("observerUpdate", mutations[0]);
          return;
        }
        const observerUpdate = function observerUpdate2() {
          emit("observerUpdate", mutations[0]);
        };
        if (window2.requestAnimationFrame) {
          window2.requestAnimationFrame(observerUpdate);
        } else {
          window2.setTimeout(observerUpdate, 0);
        }
      });
      observer.observe(target, {
        attributes: typeof options.attributes === "undefined" ? true : options.attributes,
        childList: typeof options.childList === "undefined" ? true : options.childList,
        characterData: typeof options.characterData === "undefined" ? true : options.characterData
      });
      observers.push(observer);
    };
    const init = () => {
      if (!swiper2.params.observer) return;
      if (swiper2.params.observeParents) {
        const containerParents = swiper2.$el.parents();
        for (let i = 0; i < containerParents.length; i += 1) {
          attach(containerParents[i]);
        }
      }
      attach(swiper2.$el[0], {
        childList: swiper2.params.observeSlideChildren
      });
      attach(swiper2.$wrapperEl[0], {
        attributes: false
      });
    };
    const destroy = () => {
      observers.forEach((observer) => {
        observer.disconnect();
      });
      observers.splice(0, observers.length);
    };
    extendParams({
      observer: false,
      observeParents: false,
      observeSlideChildren: false
    });
    on2("init", init);
    on2("destroy", destroy);
  }

  // node_modules/swiper/core/events-emitter.js
  var events_emitter_default = {
    on(events2, handler, priority) {
      const self = this;
      if (!self.eventsListeners || self.destroyed) return self;
      if (typeof handler !== "function") return self;
      const method = priority ? "unshift" : "push";
      events2.split(" ").forEach((event2) => {
        if (!self.eventsListeners[event2]) self.eventsListeners[event2] = [];
        self.eventsListeners[event2][method](handler);
      });
      return self;
    },
    once(events2, handler, priority) {
      const self = this;
      if (!self.eventsListeners || self.destroyed) return self;
      if (typeof handler !== "function") return self;
      function onceHandler(...args) {
        self.off(events2, onceHandler);
        if (onceHandler.__emitterProxy) {
          delete onceHandler.__emitterProxy;
        }
        handler.apply(self, args);
      }
      onceHandler.__emitterProxy = handler;
      return self.on(events2, onceHandler, priority);
    },
    onAny(handler, priority) {
      const self = this;
      if (!self.eventsListeners || self.destroyed) return self;
      if (typeof handler !== "function") return self;
      const method = priority ? "unshift" : "push";
      if (self.eventsAnyListeners.indexOf(handler) < 0) {
        self.eventsAnyListeners[method](handler);
      }
      return self;
    },
    offAny(handler) {
      const self = this;
      if (!self.eventsListeners || self.destroyed) return self;
      if (!self.eventsAnyListeners) return self;
      const index2 = self.eventsAnyListeners.indexOf(handler);
      if (index2 >= 0) {
        self.eventsAnyListeners.splice(index2, 1);
      }
      return self;
    },
    off(events2, handler) {
      const self = this;
      if (!self.eventsListeners || self.destroyed) return self;
      if (!self.eventsListeners) return self;
      events2.split(" ").forEach((event2) => {
        if (typeof handler === "undefined") {
          self.eventsListeners[event2] = [];
        } else if (self.eventsListeners[event2]) {
          self.eventsListeners[event2].forEach((eventHandler, index2) => {
            if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
              self.eventsListeners[event2].splice(index2, 1);
            }
          });
        }
      });
      return self;
    },
    emit(...args) {
      const self = this;
      if (!self.eventsListeners || self.destroyed) return self;
      if (!self.eventsListeners) return self;
      let events2;
      let data2;
      let context;
      if (typeof args[0] === "string" || Array.isArray(args[0])) {
        events2 = args[0];
        data2 = args.slice(1, args.length);
        context = self;
      } else {
        events2 = args[0].events;
        data2 = args[0].data;
        context = args[0].context || self;
      }
      data2.unshift(context);
      const eventsArray = Array.isArray(events2) ? events2 : events2.split(" ");
      eventsArray.forEach((event2) => {
        if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
          self.eventsAnyListeners.forEach((eventHandler) => {
            eventHandler.apply(context, [event2, ...data2]);
          });
        }
        if (self.eventsListeners && self.eventsListeners[event2]) {
          self.eventsListeners[event2].forEach((eventHandler) => {
            eventHandler.apply(context, data2);
          });
        }
      });
      return self;
    }
  };

  // node_modules/swiper/core/update/updateSize.js
  function updateSize() {
    const swiper2 = this;
    let width;
    let height;
    const $el = swiper2.$el;
    if (typeof swiper2.params.width !== "undefined" && swiper2.params.width !== null) {
      width = swiper2.params.width;
    } else {
      width = $el[0].clientWidth;
    }
    if (typeof swiper2.params.height !== "undefined" && swiper2.params.height !== null) {
      height = swiper2.params.height;
    } else {
      height = $el[0].clientHeight;
    }
    if (width === 0 && swiper2.isHorizontal() || height === 0 && swiper2.isVertical()) {
      return;
    }
    width = width - parseInt($el.css("padding-left") || 0, 10) - parseInt($el.css("padding-right") || 0, 10);
    height = height - parseInt($el.css("padding-top") || 0, 10) - parseInt($el.css("padding-bottom") || 0, 10);
    if (Number.isNaN(width)) width = 0;
    if (Number.isNaN(height)) height = 0;
    Object.assign(swiper2, {
      width,
      height,
      size: swiper2.isHorizontal() ? width : height
    });
  }

  // node_modules/swiper/core/update/updateSlides.js
  function updateSlides() {
    const swiper2 = this;
    function getDirectionLabel(property) {
      if (swiper2.isHorizontal()) {
        return property;
      }
      return {
        "width": "height",
        "margin-top": "margin-left",
        "margin-bottom ": "margin-right",
        "margin-left": "margin-top",
        "margin-right": "margin-bottom",
        "padding-left": "padding-top",
        "padding-right": "padding-bottom",
        "marginRight": "marginBottom"
      }[property];
    }
    function getDirectionPropertyValue(node, label) {
      return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
    }
    const params = swiper2.params;
    const {
      $wrapperEl,
      size: swiperSize,
      rtlTranslate: rtl,
      wrongRTL
    } = swiper2;
    const isVirtual = swiper2.virtual && params.virtual.enabled;
    const previousSlidesLength = isVirtual ? swiper2.virtual.slides.length : swiper2.slides.length;
    const slides = $wrapperEl.children(`.${swiper2.params.slideClass}`);
    const slidesLength = isVirtual ? swiper2.virtual.slides.length : slides.length;
    let snapGrid = [];
    const slidesGrid = [];
    const slidesSizesGrid = [];
    let offsetBefore = params.slidesOffsetBefore;
    if (typeof offsetBefore === "function") {
      offsetBefore = params.slidesOffsetBefore.call(swiper2);
    }
    let offsetAfter = params.slidesOffsetAfter;
    if (typeof offsetAfter === "function") {
      offsetAfter = params.slidesOffsetAfter.call(swiper2);
    }
    const previousSnapGridLength = swiper2.snapGrid.length;
    const previousSlidesGridLength = swiper2.slidesGrid.length;
    let spaceBetween = params.spaceBetween;
    let slidePosition = -offsetBefore;
    let prevSlideSize = 0;
    let index2 = 0;
    if (typeof swiperSize === "undefined") {
      return;
    }
    if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
    }
    swiper2.virtualSize = -spaceBetween;
    if (rtl) slides.css({
      marginLeft: "",
      marginBottom: "",
      marginTop: ""
    });
    else slides.css({
      marginRight: "",
      marginBottom: "",
      marginTop: ""
    });
    if (params.centeredSlides && params.cssMode) {
      setCSSProperty(swiper2.wrapperEl, "--swiper-centered-offset-before", "");
      setCSSProperty(swiper2.wrapperEl, "--swiper-centered-offset-after", "");
    }
    const gridEnabled = params.grid && params.grid.rows > 1 && swiper2.grid;
    if (gridEnabled) {
      swiper2.grid.initSlides(slidesLength);
    }
    let slideSize;
    const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key) => {
      return typeof params.breakpoints[key].slidesPerView !== "undefined";
    }).length > 0;
    for (let i = 0; i < slidesLength; i += 1) {
      slideSize = 0;
      const slide = slides.eq(i);
      if (gridEnabled) {
        swiper2.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
      }
      if (slide.css("display") === "none") continue;
      if (params.slidesPerView === "auto") {
        if (shouldResetSlideSize) {
          slides[i].style[getDirectionLabel("width")] = ``;
        }
        const slideStyles = getComputedStyle(slide[0]);
        const currentTransform = slide[0].style.transform;
        const currentWebKitTransform = slide[0].style.webkitTransform;
        if (currentTransform) {
          slide[0].style.transform = "none";
        }
        if (currentWebKitTransform) {
          slide[0].style.webkitTransform = "none";
        }
        if (params.roundLengths) {
          slideSize = swiper2.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
        } else {
          const width = getDirectionPropertyValue(slideStyles, "width");
          const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
          const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
          const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
          const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
          const boxSizing = slideStyles.getPropertyValue("box-sizing");
          if (boxSizing && boxSizing === "border-box") {
            slideSize = width + marginLeft + marginRight;
          } else {
            const {
              clientWidth,
              offsetWidth
            } = slide[0];
            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
          }
        }
        if (currentTransform) {
          slide[0].style.transform = currentTransform;
        }
        if (currentWebKitTransform) {
          slide[0].style.webkitTransform = currentWebKitTransform;
        }
        if (params.roundLengths) slideSize = Math.floor(slideSize);
      } else {
        slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
        if (params.roundLengths) slideSize = Math.floor(slideSize);
        if (slides[i]) {
          slides[i].style[getDirectionLabel("width")] = `${slideSize}px`;
        }
      }
      if (slides[i]) {
        slides[i].swiperSlideSize = slideSize;
      }
      slidesSizesGrid.push(slideSize);
      if (params.centeredSlides) {
        slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
        if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;
        if (params.roundLengths) slidePosition = Math.floor(slidePosition);
        if (index2 % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
      } else {
        if (params.roundLengths) slidePosition = Math.floor(slidePosition);
        if ((index2 - Math.min(swiper2.params.slidesPerGroupSkip, index2)) % swiper2.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
        slidePosition = slidePosition + slideSize + spaceBetween;
      }
      swiper2.virtualSize += slideSize + spaceBetween;
      prevSlideSize = slideSize;
      index2 += 1;
    }
    swiper2.virtualSize = Math.max(swiper2.virtualSize, swiperSize) + offsetAfter;
    if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
      $wrapperEl.css({
        width: `${swiper2.virtualSize + params.spaceBetween}px`
      });
    }
    if (params.setWrapperSize) {
      $wrapperEl.css({
        [getDirectionLabel("width")]: `${swiper2.virtualSize + params.spaceBetween}px`
      });
    }
    if (gridEnabled) {
      swiper2.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
    }
    if (!params.centeredSlides) {
      const newSlidesGrid = [];
      for (let i = 0; i < snapGrid.length; i += 1) {
        let slidesGridItem = snapGrid[i];
        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i] <= swiper2.virtualSize - swiperSize) {
          newSlidesGrid.push(slidesGridItem);
        }
      }
      snapGrid = newSlidesGrid;
      if (Math.floor(swiper2.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
        snapGrid.push(swiper2.virtualSize - swiperSize);
      }
    }
    if (snapGrid.length === 0) snapGrid = [0];
    if (params.spaceBetween !== 0) {
      const key = swiper2.isHorizontal() && rtl ? "marginLeft" : getDirectionLabel("marginRight");
      slides.filter((_, slideIndex) => {
        if (!params.cssMode) return true;
        if (slideIndex === slides.length - 1) {
          return false;
        }
        return true;
      }).css({
        [key]: `${spaceBetween}px`
      });
    }
    if (params.centeredSlides && params.centeredSlidesBounds) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach((slideSizeValue) => {
        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
      });
      allSlidesSize -= params.spaceBetween;
      const maxSnap = allSlidesSize - swiperSize;
      snapGrid = snapGrid.map((snap) => {
        if (snap < 0) return -offsetBefore;
        if (snap > maxSnap) return maxSnap + offsetAfter;
        return snap;
      });
    }
    if (params.centerInsufficientSlides) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach((slideSizeValue) => {
        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
      });
      allSlidesSize -= params.spaceBetween;
      if (allSlidesSize < swiperSize) {
        const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
        snapGrid.forEach((snap, snapIndex) => {
          snapGrid[snapIndex] = snap - allSlidesOffset;
        });
        slidesGrid.forEach((snap, snapIndex) => {
          slidesGrid[snapIndex] = snap + allSlidesOffset;
        });
      }
    }
    Object.assign(swiper2, {
      slides,
      snapGrid,
      slidesGrid,
      slidesSizesGrid
    });
    if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
      setCSSProperty(swiper2.wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
      setCSSProperty(swiper2.wrapperEl, "--swiper-centered-offset-after", `${swiper2.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
      const addToSnapGrid = -swiper2.snapGrid[0];
      const addToSlidesGrid = -swiper2.slidesGrid[0];
      swiper2.snapGrid = swiper2.snapGrid.map((v) => v + addToSnapGrid);
      swiper2.slidesGrid = swiper2.slidesGrid.map((v) => v + addToSlidesGrid);
    }
    if (slidesLength !== previousSlidesLength) {
      swiper2.emit("slidesLengthChange");
    }
    if (snapGrid.length !== previousSnapGridLength) {
      if (swiper2.params.watchOverflow) swiper2.checkOverflow();
      swiper2.emit("snapGridLengthChange");
    }
    if (slidesGrid.length !== previousSlidesGridLength) {
      swiper2.emit("slidesGridLengthChange");
    }
    if (params.watchSlidesProgress) {
      swiper2.updateSlidesOffset();
    }
    if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
      const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
      const hasClassBackfaceClassAdded = swiper2.$el.hasClass(backFaceHiddenClass);
      if (slidesLength <= params.maxBackfaceHiddenSlides) {
        if (!hasClassBackfaceClassAdded) swiper2.$el.addClass(backFaceHiddenClass);
      } else if (hasClassBackfaceClassAdded) {
        swiper2.$el.removeClass(backFaceHiddenClass);
      }
    }
  }

  // node_modules/swiper/core/update/updateAutoHeight.js
  function updateAutoHeight(speed) {
    const swiper2 = this;
    const activeSlides = [];
    const isVirtual = swiper2.virtual && swiper2.params.virtual.enabled;
    let newHeight = 0;
    let i;
    if (typeof speed === "number") {
      swiper2.setTransition(speed);
    } else if (speed === true) {
      swiper2.setTransition(swiper2.params.speed);
    }
    const getSlideByIndex = (index2) => {
      if (isVirtual) {
        return swiper2.slides.filter((el) => parseInt(el.getAttribute("data-swiper-slide-index"), 10) === index2)[0];
      }
      return swiper2.slides.eq(index2)[0];
    };
    if (swiper2.params.slidesPerView !== "auto" && swiper2.params.slidesPerView > 1) {
      if (swiper2.params.centeredSlides) {
        (swiper2.visibleSlides || dom_default([])).each((slide) => {
          activeSlides.push(slide);
        });
      } else {
        for (i = 0; i < Math.ceil(swiper2.params.slidesPerView); i += 1) {
          const index2 = swiper2.activeIndex + i;
          if (index2 > swiper2.slides.length && !isVirtual) break;
          activeSlides.push(getSlideByIndex(index2));
        }
      }
    } else {
      activeSlides.push(getSlideByIndex(swiper2.activeIndex));
    }
    for (i = 0; i < activeSlides.length; i += 1) {
      if (typeof activeSlides[i] !== "undefined") {
        const height = activeSlides[i].offsetHeight;
        newHeight = height > newHeight ? height : newHeight;
      }
    }
    if (newHeight || newHeight === 0) swiper2.$wrapperEl.css("height", `${newHeight}px`);
  }

  // node_modules/swiper/core/update/updateSlidesOffset.js
  function updateSlidesOffset() {
    const swiper2 = this;
    const slides = swiper2.slides;
    for (let i = 0; i < slides.length; i += 1) {
      slides[i].swiperSlideOffset = swiper2.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
    }
  }

  // node_modules/swiper/core/update/updateSlidesProgress.js
  function updateSlidesProgress(translate = this && this.translate || 0) {
    const swiper2 = this;
    const params = swiper2.params;
    const {
      slides,
      rtlTranslate: rtl,
      snapGrid
    } = swiper2;
    if (slides.length === 0) return;
    if (typeof slides[0].swiperSlideOffset === "undefined") swiper2.updateSlidesOffset();
    let offsetCenter = -translate;
    if (rtl) offsetCenter = translate;
    slides.removeClass(params.slideVisibleClass);
    swiper2.visibleSlidesIndexes = [];
    swiper2.visibleSlides = [];
    for (let i = 0; i < slides.length; i += 1) {
      const slide = slides[i];
      let slideOffset = slide.swiperSlideOffset;
      if (params.cssMode && params.centeredSlides) {
        slideOffset -= slides[0].swiperSlideOffset;
      }
      const slideProgress = (offsetCenter + (params.centeredSlides ? swiper2.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
      const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper2.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
      const slideBefore = -(offsetCenter - slideOffset);
      const slideAfter = slideBefore + swiper2.slidesSizesGrid[i];
      const isVisible = slideBefore >= 0 && slideBefore < swiper2.size - 1 || slideAfter > 1 && slideAfter <= swiper2.size || slideBefore <= 0 && slideAfter >= swiper2.size;
      if (isVisible) {
        swiper2.visibleSlides.push(slide);
        swiper2.visibleSlidesIndexes.push(i);
        slides.eq(i).addClass(params.slideVisibleClass);
      }
      slide.progress = rtl ? -slideProgress : slideProgress;
      slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
    }
    swiper2.visibleSlides = dom_default(swiper2.visibleSlides);
  }

  // node_modules/swiper/core/update/updateProgress.js
  function updateProgress(translate) {
    const swiper2 = this;
    if (typeof translate === "undefined") {
      const multiplier = swiper2.rtlTranslate ? -1 : 1;
      translate = swiper2 && swiper2.translate && swiper2.translate * multiplier || 0;
    }
    const params = swiper2.params;
    const translatesDiff = swiper2.maxTranslate() - swiper2.minTranslate();
    let {
      progress,
      isBeginning,
      isEnd
    } = swiper2;
    const wasBeginning = isBeginning;
    const wasEnd = isEnd;
    if (translatesDiff === 0) {
      progress = 0;
      isBeginning = true;
      isEnd = true;
    } else {
      progress = (translate - swiper2.minTranslate()) / translatesDiff;
      isBeginning = progress <= 0;
      isEnd = progress >= 1;
    }
    Object.assign(swiper2, {
      progress,
      isBeginning,
      isEnd
    });
    if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper2.updateSlidesProgress(translate);
    if (isBeginning && !wasBeginning) {
      swiper2.emit("reachBeginning toEdge");
    }
    if (isEnd && !wasEnd) {
      swiper2.emit("reachEnd toEdge");
    }
    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
      swiper2.emit("fromEdge");
    }
    swiper2.emit("progress", progress);
  }

  // node_modules/swiper/core/update/updateSlidesClasses.js
  function updateSlidesClasses() {
    const swiper2 = this;
    const {
      slides,
      params,
      $wrapperEl,
      activeIndex,
      realIndex
    } = swiper2;
    const isVirtual = swiper2.virtual && params.virtual.enabled;
    slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
    let activeSlide;
    if (isVirtual) {
      activeSlide = swiper2.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
    } else {
      activeSlide = slides.eq(activeIndex);
    }
    activeSlide.addClass(params.slideActiveClass);
    if (params.loop) {
      if (activeSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
      } else {
        $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
      }
    }
    let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
    if (params.loop && nextSlide.length === 0) {
      nextSlide = slides.eq(0);
      nextSlide.addClass(params.slideNextClass);
    }
    let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
    if (params.loop && prevSlide.length === 0) {
      prevSlide = slides.eq(-1);
      prevSlide.addClass(params.slidePrevClass);
    }
    if (params.loop) {
      if (nextSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass);
      } else {
        $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass);
      }
      if (prevSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass);
      } else {
        $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass);
      }
    }
    swiper2.emitSlidesClasses();
  }

  // node_modules/swiper/core/update/updateActiveIndex.js
  function updateActiveIndex(newActiveIndex) {
    const swiper2 = this;
    const translate = swiper2.rtlTranslate ? swiper2.translate : -swiper2.translate;
    const {
      slidesGrid,
      snapGrid,
      params,
      activeIndex: previousIndex,
      realIndex: previousRealIndex,
      snapIndex: previousSnapIndex
    } = swiper2;
    let activeIndex = newActiveIndex;
    let snapIndex;
    if (typeof activeIndex === "undefined") {
      for (let i = 0; i < slidesGrid.length; i += 1) {
        if (typeof slidesGrid[i + 1] !== "undefined") {
          if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
            activeIndex = i;
          } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
            activeIndex = i + 1;
          }
        } else if (translate >= slidesGrid[i]) {
          activeIndex = i;
        }
      }
      if (params.normalizeSlideIndex) {
        if (activeIndex < 0 || typeof activeIndex === "undefined") activeIndex = 0;
      }
    }
    if (snapGrid.indexOf(translate) >= 0) {
      snapIndex = snapGrid.indexOf(translate);
    } else {
      const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
      snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
    }
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
    if (activeIndex === previousIndex) {
      if (snapIndex !== previousSnapIndex) {
        swiper2.snapIndex = snapIndex;
        swiper2.emit("snapIndexChange");
      }
      return;
    }
    const realIndex = parseInt(swiper2.slides.eq(activeIndex).attr("data-swiper-slide-index") || activeIndex, 10);
    Object.assign(swiper2, {
      snapIndex,
      realIndex,
      previousIndex,
      activeIndex
    });
    swiper2.emit("activeIndexChange");
    swiper2.emit("snapIndexChange");
    if (previousRealIndex !== realIndex) {
      swiper2.emit("realIndexChange");
    }
    if (swiper2.initialized || swiper2.params.runCallbacksOnInit) {
      swiper2.emit("slideChange");
    }
  }

  // node_modules/swiper/core/update/updateClickedSlide.js
  function updateClickedSlide(e) {
    const swiper2 = this;
    const params = swiper2.params;
    const slide = dom_default(e).closest(`.${params.slideClass}`)[0];
    let slideFound = false;
    let slideIndex;
    if (slide) {
      for (let i = 0; i < swiper2.slides.length; i += 1) {
        if (swiper2.slides[i] === slide) {
          slideFound = true;
          slideIndex = i;
          break;
        }
      }
    }
    if (slide && slideFound) {
      swiper2.clickedSlide = slide;
      if (swiper2.virtual && swiper2.params.virtual.enabled) {
        swiper2.clickedIndex = parseInt(dom_default(slide).attr("data-swiper-slide-index"), 10);
      } else {
        swiper2.clickedIndex = slideIndex;
      }
    } else {
      swiper2.clickedSlide = void 0;
      swiper2.clickedIndex = void 0;
      return;
    }
    if (params.slideToClickedSlide && swiper2.clickedIndex !== void 0 && swiper2.clickedIndex !== swiper2.activeIndex) {
      swiper2.slideToClickedSlide();
    }
  }

  // node_modules/swiper/core/update/index.js
  var update_default = {
    updateSize,
    updateSlides,
    updateAutoHeight,
    updateSlidesOffset,
    updateSlidesProgress,
    updateProgress,
    updateSlidesClasses,
    updateActiveIndex,
    updateClickedSlide
  };

  // node_modules/swiper/core/translate/getTranslate.js
  function getSwiperTranslate(axis = this.isHorizontal() ? "x" : "y") {
    const swiper2 = this;
    const {
      params,
      rtlTranslate: rtl,
      translate,
      $wrapperEl
    } = swiper2;
    if (params.virtualTranslate) {
      return rtl ? -translate : translate;
    }
    if (params.cssMode) {
      return translate;
    }
    let currentTranslate = getTranslate($wrapperEl[0], axis);
    if (rtl) currentTranslate = -currentTranslate;
    return currentTranslate || 0;
  }

  // node_modules/swiper/core/translate/setTranslate.js
  function setTranslate(translate, byController) {
    const swiper2 = this;
    const {
      rtlTranslate: rtl,
      params,
      $wrapperEl,
      wrapperEl,
      progress
    } = swiper2;
    let x = 0;
    let y = 0;
    const z = 0;
    if (swiper2.isHorizontal()) {
      x = rtl ? -translate : translate;
    } else {
      y = translate;
    }
    if (params.roundLengths) {
      x = Math.floor(x);
      y = Math.floor(y);
    }
    if (params.cssMode) {
      wrapperEl[swiper2.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper2.isHorizontal() ? -x : -y;
    } else if (!params.virtualTranslate) {
      $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
    }
    swiper2.previousTranslate = swiper2.translate;
    swiper2.translate = swiper2.isHorizontal() ? x : y;
    let newProgress;
    const translatesDiff = swiper2.maxTranslate() - swiper2.minTranslate();
    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (translate - swiper2.minTranslate()) / translatesDiff;
    }
    if (newProgress !== progress) {
      swiper2.updateProgress(translate);
    }
    swiper2.emit("setTranslate", swiper2.translate, byController);
  }

  // node_modules/swiper/core/translate/minTranslate.js
  function minTranslate() {
    return -this.snapGrid[0];
  }

  // node_modules/swiper/core/translate/maxTranslate.js
  function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1];
  }

  // node_modules/swiper/core/translate/translateTo.js
  function translateTo(translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
    const swiper2 = this;
    const {
      params,
      wrapperEl
    } = swiper2;
    if (swiper2.animating && params.preventInteractionOnTransition) {
      return false;
    }
    const minTranslate2 = swiper2.minTranslate();
    const maxTranslate2 = swiper2.maxTranslate();
    let newTranslate;
    if (translateBounds && translate > minTranslate2) newTranslate = minTranslate2;
    else if (translateBounds && translate < maxTranslate2) newTranslate = maxTranslate2;
    else newTranslate = translate;
    swiper2.updateProgress(newTranslate);
    if (params.cssMode) {
      const isH = swiper2.isHorizontal();
      if (speed === 0) {
        wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
      } else {
        if (!swiper2.support.smoothScroll) {
          animateCSSModeScroll({
            swiper: swiper2,
            targetPosition: -newTranslate,
            side: isH ? "left" : "top"
          });
          return true;
        }
        wrapperEl.scrollTo({
          [isH ? "left" : "top"]: -newTranslate,
          behavior: "smooth"
        });
      }
      return true;
    }
    if (speed === 0) {
      swiper2.setTransition(0);
      swiper2.setTranslate(newTranslate);
      if (runCallbacks) {
        swiper2.emit("beforeTransitionStart", speed, internal);
        swiper2.emit("transitionEnd");
      }
    } else {
      swiper2.setTransition(speed);
      swiper2.setTranslate(newTranslate);
      if (runCallbacks) {
        swiper2.emit("beforeTransitionStart", speed, internal);
        swiper2.emit("transitionStart");
      }
      if (!swiper2.animating) {
        swiper2.animating = true;
        if (!swiper2.onTranslateToWrapperTransitionEnd) {
          swiper2.onTranslateToWrapperTransitionEnd = function transitionEnd3(e) {
            if (!swiper2 || swiper2.destroyed) return;
            if (e.target !== this) return;
            swiper2.$wrapperEl[0].removeEventListener("transitionend", swiper2.onTranslateToWrapperTransitionEnd);
            swiper2.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper2.onTranslateToWrapperTransitionEnd);
            swiper2.onTranslateToWrapperTransitionEnd = null;
            delete swiper2.onTranslateToWrapperTransitionEnd;
            if (runCallbacks) {
              swiper2.emit("transitionEnd");
            }
          };
        }
        swiper2.$wrapperEl[0].addEventListener("transitionend", swiper2.onTranslateToWrapperTransitionEnd);
        swiper2.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper2.onTranslateToWrapperTransitionEnd);
      }
    }
    return true;
  }

  // node_modules/swiper/core/translate/index.js
  var translate_default = {
    getTranslate: getSwiperTranslate,
    setTranslate,
    minTranslate,
    maxTranslate,
    translateTo
  };

  // node_modules/swiper/core/transition/setTransition.js
  function setTransition(duration, byController) {
    const swiper2 = this;
    if (!swiper2.params.cssMode) {
      swiper2.$wrapperEl.transition(duration);
    }
    swiper2.emit("setTransition", duration, byController);
  }

  // node_modules/swiper/core/transition/transitionEmit.js
  function transitionEmit({
    swiper: swiper2,
    runCallbacks,
    direction,
    step
  }) {
    const {
      activeIndex,
      previousIndex
    } = swiper2;
    let dir = direction;
    if (!dir) {
      if (activeIndex > previousIndex) dir = "next";
      else if (activeIndex < previousIndex) dir = "prev";
      else dir = "reset";
    }
    swiper2.emit(`transition${step}`);
    if (runCallbacks && activeIndex !== previousIndex) {
      if (dir === "reset") {
        swiper2.emit(`slideResetTransition${step}`);
        return;
      }
      swiper2.emit(`slideChangeTransition${step}`);
      if (dir === "next") {
        swiper2.emit(`slideNextTransition${step}`);
      } else {
        swiper2.emit(`slidePrevTransition${step}`);
      }
    }
  }

  // node_modules/swiper/core/transition/transitionStart.js
  function transitionStart(runCallbacks = true, direction) {
    const swiper2 = this;
    const {
      params
    } = swiper2;
    if (params.cssMode) return;
    if (params.autoHeight) {
      swiper2.updateAutoHeight();
    }
    transitionEmit({
      swiper: swiper2,
      runCallbacks,
      direction,
      step: "Start"
    });
  }

  // node_modules/swiper/core/transition/transitionEnd.js
  function transitionEnd2(runCallbacks = true, direction) {
    const swiper2 = this;
    const {
      params
    } = swiper2;
    swiper2.animating = false;
    if (params.cssMode) return;
    swiper2.setTransition(0);
    transitionEmit({
      swiper: swiper2,
      runCallbacks,
      direction,
      step: "End"
    });
  }

  // node_modules/swiper/core/transition/index.js
  var transition_default = {
    setTransition,
    transitionStart,
    transitionEnd: transitionEnd2
  };

  // node_modules/swiper/core/slide/slideTo.js
  function slideTo(index2 = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {
    if (typeof index2 !== "number" && typeof index2 !== "string") {
      throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index2}] given.`);
    }
    if (typeof index2 === "string") {
      const indexAsNumber = parseInt(index2, 10);
      const isValidNumber = isFinite(indexAsNumber);
      if (!isValidNumber) {
        throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index2}] given.`);
      }
      index2 = indexAsNumber;
    }
    const swiper2 = this;
    let slideIndex = index2;
    if (slideIndex < 0) slideIndex = 0;
    const {
      params,
      snapGrid,
      slidesGrid,
      previousIndex,
      activeIndex,
      rtlTranslate: rtl,
      wrapperEl,
      enabled
    } = swiper2;
    if (swiper2.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
      return false;
    }
    const skip = Math.min(swiper2.params.slidesPerGroupSkip, slideIndex);
    let snapIndex = skip + Math.floor((slideIndex - skip) / swiper2.params.slidesPerGroup);
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
    const translate = -snapGrid[snapIndex];
    if (params.normalizeSlideIndex) {
      for (let i = 0; i < slidesGrid.length; i += 1) {
        const normalizedTranslate = -Math.floor(translate * 100);
        const normalizedGrid = Math.floor(slidesGrid[i] * 100);
        const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
        if (typeof slidesGrid[i + 1] !== "undefined") {
          if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
            slideIndex = i;
          } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
            slideIndex = i + 1;
          }
        } else if (normalizedTranslate >= normalizedGrid) {
          slideIndex = i;
        }
      }
    }
    if (swiper2.initialized && slideIndex !== activeIndex) {
      if (!swiper2.allowSlideNext && translate < swiper2.translate && translate < swiper2.minTranslate()) {
        return false;
      }
      if (!swiper2.allowSlidePrev && translate > swiper2.translate && translate > swiper2.maxTranslate()) {
        if ((activeIndex || 0) !== slideIndex) return false;
      }
    }
    if (slideIndex !== (previousIndex || 0) && runCallbacks) {
      swiper2.emit("beforeSlideChangeStart");
    }
    swiper2.updateProgress(translate);
    let direction;
    if (slideIndex > activeIndex) direction = "next";
    else if (slideIndex < activeIndex) direction = "prev";
    else direction = "reset";
    if (rtl && -translate === swiper2.translate || !rtl && translate === swiper2.translate) {
      swiper2.updateActiveIndex(slideIndex);
      if (params.autoHeight) {
        swiper2.updateAutoHeight();
      }
      swiper2.updateSlidesClasses();
      if (params.effect !== "slide") {
        swiper2.setTranslate(translate);
      }
      if (direction !== "reset") {
        swiper2.transitionStart(runCallbacks, direction);
        swiper2.transitionEnd(runCallbacks, direction);
      }
      return false;
    }
    if (params.cssMode) {
      const isH = swiper2.isHorizontal();
      const t = rtl ? translate : -translate;
      if (speed === 0) {
        const isVirtual = swiper2.virtual && swiper2.params.virtual.enabled;
        if (isVirtual) {
          swiper2.wrapperEl.style.scrollSnapType = "none";
          swiper2._immediateVirtual = true;
        }
        wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
        if (isVirtual) {
          requestAnimationFrame(() => {
            swiper2.wrapperEl.style.scrollSnapType = "";
            swiper2._swiperImmediateVirtual = false;
          });
        }
      } else {
        if (!swiper2.support.smoothScroll) {
          animateCSSModeScroll({
            swiper: swiper2,
            targetPosition: t,
            side: isH ? "left" : "top"
          });
          return true;
        }
        wrapperEl.scrollTo({
          [isH ? "left" : "top"]: t,
          behavior: "smooth"
        });
      }
      return true;
    }
    swiper2.setTransition(speed);
    swiper2.setTranslate(translate);
    swiper2.updateActiveIndex(slideIndex);
    swiper2.updateSlidesClasses();
    swiper2.emit("beforeTransitionStart", speed, internal);
    swiper2.transitionStart(runCallbacks, direction);
    if (speed === 0) {
      swiper2.transitionEnd(runCallbacks, direction);
    } else if (!swiper2.animating) {
      swiper2.animating = true;
      if (!swiper2.onSlideToWrapperTransitionEnd) {
        swiper2.onSlideToWrapperTransitionEnd = function transitionEnd3(e) {
          if (!swiper2 || swiper2.destroyed) return;
          if (e.target !== this) return;
          swiper2.$wrapperEl[0].removeEventListener("transitionend", swiper2.onSlideToWrapperTransitionEnd);
          swiper2.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper2.onSlideToWrapperTransitionEnd);
          swiper2.onSlideToWrapperTransitionEnd = null;
          delete swiper2.onSlideToWrapperTransitionEnd;
          swiper2.transitionEnd(runCallbacks, direction);
        };
      }
      swiper2.$wrapperEl[0].addEventListener("transitionend", swiper2.onSlideToWrapperTransitionEnd);
      swiper2.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper2.onSlideToWrapperTransitionEnd);
    }
    return true;
  }

  // node_modules/swiper/core/slide/slideToLoop.js
  function slideToLoop(index2 = 0, speed = this.params.speed, runCallbacks = true, internal) {
    if (typeof index2 === "string") {
      const indexAsNumber = parseInt(index2, 10);
      const isValidNumber = isFinite(indexAsNumber);
      if (!isValidNumber) {
        throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index2}] given.`);
      }
      index2 = indexAsNumber;
    }
    const swiper2 = this;
    let newIndex = index2;
    if (swiper2.params.loop) {
      newIndex += swiper2.loopedSlides;
    }
    return swiper2.slideTo(newIndex, speed, runCallbacks, internal);
  }

  // node_modules/swiper/core/slide/slideNext.js
  function slideNext(speed = this.params.speed, runCallbacks = true, internal) {
    const swiper2 = this;
    const {
      animating,
      enabled,
      params
    } = swiper2;
    if (!enabled) return swiper2;
    let perGroup = params.slidesPerGroup;
    if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      perGroup = Math.max(swiper2.slidesPerViewDynamic("current", true), 1);
    }
    const increment = swiper2.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
    if (params.loop) {
      if (animating && params.loopPreventsSlide) return false;
      swiper2.loopFix();
      swiper2._clientLeft = swiper2.$wrapperEl[0].clientLeft;
    }
    if (params.rewind && swiper2.isEnd) {
      return swiper2.slideTo(0, speed, runCallbacks, internal);
    }
    return swiper2.slideTo(swiper2.activeIndex + increment, speed, runCallbacks, internal);
  }

  // node_modules/swiper/core/slide/slidePrev.js
  function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {
    const swiper2 = this;
    const {
      params,
      animating,
      snapGrid,
      slidesGrid,
      rtlTranslate,
      enabled
    } = swiper2;
    if (!enabled) return swiper2;
    if (params.loop) {
      if (animating && params.loopPreventsSlide) return false;
      swiper2.loopFix();
      swiper2._clientLeft = swiper2.$wrapperEl[0].clientLeft;
    }
    const translate = rtlTranslate ? swiper2.translate : -swiper2.translate;
    function normalize(val) {
      if (val < 0) return -Math.floor(Math.abs(val));
      return Math.floor(val);
    }
    const normalizedTranslate = normalize(translate);
    const normalizedSnapGrid = snapGrid.map((val) => normalize(val));
    let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
    if (typeof prevSnap === "undefined" && params.cssMode) {
      let prevSnapIndex;
      snapGrid.forEach((snap, snapIndex) => {
        if (normalizedTranslate >= snap) {
          prevSnapIndex = snapIndex;
        }
      });
      if (typeof prevSnapIndex !== "undefined") {
        prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
      }
    }
    let prevIndex = 0;
    if (typeof prevSnap !== "undefined") {
      prevIndex = slidesGrid.indexOf(prevSnap);
      if (prevIndex < 0) prevIndex = swiper2.activeIndex - 1;
      if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
        prevIndex = prevIndex - swiper2.slidesPerViewDynamic("previous", true) + 1;
        prevIndex = Math.max(prevIndex, 0);
      }
    }
    if (params.rewind && swiper2.isBeginning) {
      const lastIndex = swiper2.params.virtual && swiper2.params.virtual.enabled && swiper2.virtual ? swiper2.virtual.slides.length - 1 : swiper2.slides.length - 1;
      return swiper2.slideTo(lastIndex, speed, runCallbacks, internal);
    }
    return swiper2.slideTo(prevIndex, speed, runCallbacks, internal);
  }

  // node_modules/swiper/core/slide/slideReset.js
  function slideReset(speed = this.params.speed, runCallbacks = true, internal) {
    const swiper2 = this;
    return swiper2.slideTo(swiper2.activeIndex, speed, runCallbacks, internal);
  }

  // node_modules/swiper/core/slide/slideToClosest.js
  function slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {
    const swiper2 = this;
    let index2 = swiper2.activeIndex;
    const skip = Math.min(swiper2.params.slidesPerGroupSkip, index2);
    const snapIndex = skip + Math.floor((index2 - skip) / swiper2.params.slidesPerGroup);
    const translate = swiper2.rtlTranslate ? swiper2.translate : -swiper2.translate;
    if (translate >= swiper2.snapGrid[snapIndex]) {
      const currentSnap = swiper2.snapGrid[snapIndex];
      const nextSnap = swiper2.snapGrid[snapIndex + 1];
      if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
        index2 += swiper2.params.slidesPerGroup;
      }
    } else {
      const prevSnap = swiper2.snapGrid[snapIndex - 1];
      const currentSnap = swiper2.snapGrid[snapIndex];
      if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
        index2 -= swiper2.params.slidesPerGroup;
      }
    }
    index2 = Math.max(index2, 0);
    index2 = Math.min(index2, swiper2.slidesGrid.length - 1);
    return swiper2.slideTo(index2, speed, runCallbacks, internal);
  }

  // node_modules/swiper/core/slide/slideToClickedSlide.js
  function slideToClickedSlide() {
    const swiper2 = this;
    const {
      params,
      $wrapperEl
    } = swiper2;
    const slidesPerView = params.slidesPerView === "auto" ? swiper2.slidesPerViewDynamic() : params.slidesPerView;
    let slideToIndex = swiper2.clickedIndex;
    let realIndex;
    if (params.loop) {
      if (swiper2.animating) return;
      realIndex = parseInt(dom_default(swiper2.clickedSlide).attr("data-swiper-slide-index"), 10);
      if (params.centeredSlides) {
        if (slideToIndex < swiper2.loopedSlides - slidesPerView / 2 || slideToIndex > swiper2.slides.length - swiper2.loopedSlides + slidesPerView / 2) {
          swiper2.loopFix();
          slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
          nextTick(() => {
            swiper2.slideTo(slideToIndex);
          });
        } else {
          swiper2.slideTo(slideToIndex);
        }
      } else if (slideToIndex > swiper2.slides.length - slidesPerView) {
        swiper2.loopFix();
        slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
        nextTick(() => {
          swiper2.slideTo(slideToIndex);
        });
      } else {
        swiper2.slideTo(slideToIndex);
      }
    } else {
      swiper2.slideTo(slideToIndex);
    }
  }

  // node_modules/swiper/core/slide/index.js
  var slide_default = {
    slideTo,
    slideToLoop,
    slideNext,
    slidePrev,
    slideReset,
    slideToClosest,
    slideToClickedSlide
  };

  // node_modules/swiper/core/loop/loopCreate.js
  function loopCreate() {
    const swiper2 = this;
    const document2 = getDocument();
    const {
      params,
      $wrapperEl
    } = swiper2;
    const $selector = $wrapperEl.children().length > 0 ? dom_default($wrapperEl.children()[0].parentNode) : $wrapperEl;
    $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
    let slides = $selector.children(`.${params.slideClass}`);
    if (params.loopFillGroupWithBlank) {
      const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
      if (blankSlidesNum !== params.slidesPerGroup) {
        for (let i = 0; i < blankSlidesNum; i += 1) {
          const blankNode = dom_default(document2.createElement("div")).addClass(`${params.slideClass} ${params.slideBlankClass}`);
          $selector.append(blankNode);
        }
        slides = $selector.children(`.${params.slideClass}`);
      }
    }
    if (params.slidesPerView === "auto" && !params.loopedSlides) params.loopedSlides = slides.length;
    swiper2.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
    swiper2.loopedSlides += params.loopAdditionalSlides;
    if (swiper2.loopedSlides > slides.length && swiper2.params.loopedSlidesLimit) {
      swiper2.loopedSlides = slides.length;
    }
    const prependSlides = [];
    const appendSlides = [];
    slides.each((el, index2) => {
      const slide = dom_default(el);
      slide.attr("data-swiper-slide-index", index2);
    });
    for (let i = 0; i < swiper2.loopedSlides; i += 1) {
      const index2 = i - Math.floor(i / slides.length) * slides.length;
      appendSlides.push(slides.eq(index2)[0]);
      prependSlides.unshift(slides.eq(slides.length - index2 - 1)[0]);
    }
    for (let i = 0; i < appendSlides.length; i += 1) {
      $selector.append(dom_default(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
    }
    for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
      $selector.prepend(dom_default(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
    }
  }

  // node_modules/swiper/core/loop/loopFix.js
  function loopFix() {
    const swiper2 = this;
    swiper2.emit("beforeLoopFix");
    const {
      activeIndex,
      slides,
      loopedSlides,
      allowSlidePrev,
      allowSlideNext,
      snapGrid,
      rtlTranslate: rtl
    } = swiper2;
    let newIndex;
    swiper2.allowSlidePrev = true;
    swiper2.allowSlideNext = true;
    const snapTranslate = -snapGrid[activeIndex];
    const diff = snapTranslate - swiper2.getTranslate();
    if (activeIndex < loopedSlides) {
      newIndex = slides.length - loopedSlides * 3 + activeIndex;
      newIndex += loopedSlides;
      const slideChanged = swiper2.slideTo(newIndex, 0, false, true);
      if (slideChanged && diff !== 0) {
        swiper2.setTranslate((rtl ? -swiper2.translate : swiper2.translate) - diff);
      }
    } else if (activeIndex >= slides.length - loopedSlides) {
      newIndex = -slides.length + activeIndex + loopedSlides;
      newIndex += loopedSlides;
      const slideChanged = swiper2.slideTo(newIndex, 0, false, true);
      if (slideChanged && diff !== 0) {
        swiper2.setTranslate((rtl ? -swiper2.translate : swiper2.translate) - diff);
      }
    }
    swiper2.allowSlidePrev = allowSlidePrev;
    swiper2.allowSlideNext = allowSlideNext;
    swiper2.emit("loopFix");
  }

  // node_modules/swiper/core/loop/loopDestroy.js
  function loopDestroy() {
    const swiper2 = this;
    const {
      $wrapperEl,
      params,
      slides
    } = swiper2;
    $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
    slides.removeAttr("data-swiper-slide-index");
  }

  // node_modules/swiper/core/loop/index.js
  var loop_default = {
    loopCreate,
    loopFix,
    loopDestroy
  };

  // node_modules/swiper/core/grab-cursor/setGrabCursor.js
  function setGrabCursor(moving) {
    const swiper2 = this;
    if (swiper2.support.touch || !swiper2.params.simulateTouch || swiper2.params.watchOverflow && swiper2.isLocked || swiper2.params.cssMode) return;
    const el = swiper2.params.touchEventsTarget === "container" ? swiper2.el : swiper2.wrapperEl;
    el.style.cursor = "move";
    el.style.cursor = moving ? "grabbing" : "grab";
  }

  // node_modules/swiper/core/grab-cursor/unsetGrabCursor.js
  function unsetGrabCursor() {
    const swiper2 = this;
    if (swiper2.support.touch || swiper2.params.watchOverflow && swiper2.isLocked || swiper2.params.cssMode) {
      return;
    }
    swiper2[swiper2.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
  }

  // node_modules/swiper/core/grab-cursor/index.js
  var grab_cursor_default = {
    setGrabCursor,
    unsetGrabCursor
  };

  // node_modules/swiper/core/events/onTouchStart.js
  function closestElement(selector, base = this) {
    function __closestFrom(el) {
      if (!el || el === getDocument() || el === getWindow()) return null;
      if (el.assignedSlot) el = el.assignedSlot;
      const found = el.closest(selector);
      if (!found && !el.getRootNode) {
        return null;
      }
      return found || __closestFrom(el.getRootNode().host);
    }
    return __closestFrom(base);
  }
  function onTouchStart(event2) {
    const swiper2 = this;
    const document2 = getDocument();
    const window2 = getWindow();
    const data2 = swiper2.touchEventsData;
    const {
      params,
      touches,
      enabled
    } = swiper2;
    if (!enabled) return;
    if (swiper2.animating && params.preventInteractionOnTransition) {
      return;
    }
    if (!swiper2.animating && params.cssMode && params.loop) {
      swiper2.loopFix();
    }
    let e = event2;
    if (e.originalEvent) e = e.originalEvent;
    let $targetEl = dom_default(e.target);
    if (params.touchEventsTarget === "wrapper") {
      if (!$targetEl.closest(swiper2.wrapperEl).length) return;
    }
    data2.isTouchEvent = e.type === "touchstart";
    if (!data2.isTouchEvent && "which" in e && e.which === 3) return;
    if (!data2.isTouchEvent && "button" in e && e.button > 0) return;
    if (data2.isTouched && data2.isMoved) return;
    const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
    const eventPath = event2.composedPath ? event2.composedPath() : event2.path;
    if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
      $targetEl = dom_default(eventPath[0]);
    }
    const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
    const isTargetShadow = !!(e.target && e.target.shadowRoot);
    if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, $targetEl[0]) : $targetEl.closest(noSwipingSelector)[0])) {
      swiper2.allowClick = true;
      return;
    }
    if (params.swipeHandler) {
      if (!$targetEl.closest(params.swipeHandler)[0]) return;
    }
    touches.currentX = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
    touches.currentY = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
    const startX = touches.currentX;
    const startY = touches.currentY;
    const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
    const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
      if (edgeSwipeDetection === "prevent") {
        event2.preventDefault();
      } else {
        return;
      }
    }
    Object.assign(data2, {
      isTouched: true,
      isMoved: false,
      allowTouchCallbacks: true,
      isScrolling: void 0,
      startMoving: void 0
    });
    touches.startX = startX;
    touches.startY = startY;
    data2.touchStartTime = now();
    swiper2.allowClick = true;
    swiper2.updateSize();
    swiper2.swipeDirection = void 0;
    if (params.threshold > 0) data2.allowThresholdMove = false;
    if (e.type !== "touchstart") {
      let preventDefault = true;
      if ($targetEl.is(data2.focusableElements)) {
        preventDefault = false;
        if ($targetEl[0].nodeName === "SELECT") {
          data2.isTouched = false;
        }
      }
      if (document2.activeElement && dom_default(document2.activeElement).is(data2.focusableElements) && document2.activeElement !== $targetEl[0]) {
        document2.activeElement.blur();
      }
      const shouldPreventDefault = preventDefault && swiper2.allowTouchMove && params.touchStartPreventDefault;
      if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
        e.preventDefault();
      }
    }
    if (swiper2.params.freeMode && swiper2.params.freeMode.enabled && swiper2.freeMode && swiper2.animating && !params.cssMode) {
      swiper2.freeMode.onTouchStart();
    }
    swiper2.emit("touchStart", e);
  }

  // node_modules/swiper/core/events/onTouchMove.js
  function onTouchMove(event2) {
    const document2 = getDocument();
    const swiper2 = this;
    const data2 = swiper2.touchEventsData;
    const {
      params,
      touches,
      rtlTranslate: rtl,
      enabled
    } = swiper2;
    if (!enabled) return;
    let e = event2;
    if (e.originalEvent) e = e.originalEvent;
    if (!data2.isTouched) {
      if (data2.startMoving && data2.isScrolling) {
        swiper2.emit("touchMoveOpposite", e);
      }
      return;
    }
    if (data2.isTouchEvent && e.type !== "touchmove") return;
    const targetTouch = e.type === "touchmove" && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
    const pageX = e.type === "touchmove" ? targetTouch.pageX : e.pageX;
    const pageY = e.type === "touchmove" ? targetTouch.pageY : e.pageY;
    if (e.preventedByNestedSwiper) {
      touches.startX = pageX;
      touches.startY = pageY;
      return;
    }
    if (!swiper2.allowTouchMove) {
      if (!dom_default(e.target).is(data2.focusableElements)) {
        swiper2.allowClick = false;
      }
      if (data2.isTouched) {
        Object.assign(touches, {
          startX: pageX,
          startY: pageY,
          currentX: pageX,
          currentY: pageY
        });
        data2.touchStartTime = now();
      }
      return;
    }
    if (data2.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
      if (swiper2.isVertical()) {
        if (pageY < touches.startY && swiper2.translate <= swiper2.maxTranslate() || pageY > touches.startY && swiper2.translate >= swiper2.minTranslate()) {
          data2.isTouched = false;
          data2.isMoved = false;
          return;
        }
      } else if (pageX < touches.startX && swiper2.translate <= swiper2.maxTranslate() || pageX > touches.startX && swiper2.translate >= swiper2.minTranslate()) {
        return;
      }
    }
    if (data2.isTouchEvent && document2.activeElement) {
      if (e.target === document2.activeElement && dom_default(e.target).is(data2.focusableElements)) {
        data2.isMoved = true;
        swiper2.allowClick = false;
        return;
      }
    }
    if (data2.allowTouchCallbacks) {
      swiper2.emit("touchMove", e);
    }
    if (e.targetTouches && e.targetTouches.length > 1) return;
    touches.currentX = pageX;
    touches.currentY = pageY;
    const diffX = touches.currentX - touches.startX;
    const diffY = touches.currentY - touches.startY;
    if (swiper2.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper2.params.threshold) return;
    if (typeof data2.isScrolling === "undefined") {
      let touchAngle;
      if (swiper2.isHorizontal() && touches.currentY === touches.startY || swiper2.isVertical() && touches.currentX === touches.startX) {
        data2.isScrolling = false;
      } else {
        if (diffX * diffX + diffY * diffY >= 25) {
          touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
          data2.isScrolling = swiper2.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
        }
      }
    }
    if (data2.isScrolling) {
      swiper2.emit("touchMoveOpposite", e);
    }
    if (typeof data2.startMoving === "undefined") {
      if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
        data2.startMoving = true;
      }
    }
    if (data2.isScrolling) {
      data2.isTouched = false;
      return;
    }
    if (!data2.startMoving) {
      return;
    }
    swiper2.allowClick = false;
    if (!params.cssMode && e.cancelable) {
      e.preventDefault();
    }
    if (params.touchMoveStopPropagation && !params.nested) {
      e.stopPropagation();
    }
    if (!data2.isMoved) {
      if (params.loop && !params.cssMode) {
        swiper2.loopFix();
      }
      data2.startTranslate = swiper2.getTranslate();
      swiper2.setTransition(0);
      if (swiper2.animating) {
        swiper2.$wrapperEl.trigger("webkitTransitionEnd transitionend");
      }
      data2.allowMomentumBounce = false;
      if (params.grabCursor && (swiper2.allowSlideNext === true || swiper2.allowSlidePrev === true)) {
        swiper2.setGrabCursor(true);
      }
      swiper2.emit("sliderFirstMove", e);
    }
    swiper2.emit("sliderMove", e);
    data2.isMoved = true;
    let diff = swiper2.isHorizontal() ? diffX : diffY;
    touches.diff = diff;
    diff *= params.touchRatio;
    if (rtl) diff = -diff;
    swiper2.swipeDirection = diff > 0 ? "prev" : "next";
    data2.currentTranslate = diff + data2.startTranslate;
    let disableParentSwiper = true;
    let resistanceRatio = params.resistanceRatio;
    if (params.touchReleaseOnEdges) {
      resistanceRatio = 0;
    }
    if (diff > 0 && data2.currentTranslate > swiper2.minTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) data2.currentTranslate = swiper2.minTranslate() - 1 + (-swiper2.minTranslate() + data2.startTranslate + diff) ** resistanceRatio;
    } else if (diff < 0 && data2.currentTranslate < swiper2.maxTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) data2.currentTranslate = swiper2.maxTranslate() + 1 - (swiper2.maxTranslate() - data2.startTranslate - diff) ** resistanceRatio;
    }
    if (disableParentSwiper) {
      e.preventedByNestedSwiper = true;
    }
    if (!swiper2.allowSlideNext && swiper2.swipeDirection === "next" && data2.currentTranslate < data2.startTranslate) {
      data2.currentTranslate = data2.startTranslate;
    }
    if (!swiper2.allowSlidePrev && swiper2.swipeDirection === "prev" && data2.currentTranslate > data2.startTranslate) {
      data2.currentTranslate = data2.startTranslate;
    }
    if (!swiper2.allowSlidePrev && !swiper2.allowSlideNext) {
      data2.currentTranslate = data2.startTranslate;
    }
    if (params.threshold > 0) {
      if (Math.abs(diff) > params.threshold || data2.allowThresholdMove) {
        if (!data2.allowThresholdMove) {
          data2.allowThresholdMove = true;
          touches.startX = touches.currentX;
          touches.startY = touches.currentY;
          data2.currentTranslate = data2.startTranslate;
          touches.diff = swiper2.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
          return;
        }
      } else {
        data2.currentTranslate = data2.startTranslate;
        return;
      }
    }
    if (!params.followFinger || params.cssMode) return;
    if (params.freeMode && params.freeMode.enabled && swiper2.freeMode || params.watchSlidesProgress) {
      swiper2.updateActiveIndex();
      swiper2.updateSlidesClasses();
    }
    if (swiper2.params.freeMode && params.freeMode.enabled && swiper2.freeMode) {
      swiper2.freeMode.onTouchMove();
    }
    swiper2.updateProgress(data2.currentTranslate);
    swiper2.setTranslate(data2.currentTranslate);
  }

  // node_modules/swiper/core/events/onTouchEnd.js
  function onTouchEnd(event2) {
    const swiper2 = this;
    const data2 = swiper2.touchEventsData;
    const {
      params,
      touches,
      rtlTranslate: rtl,
      slidesGrid,
      enabled
    } = swiper2;
    if (!enabled) return;
    let e = event2;
    if (e.originalEvent) e = e.originalEvent;
    if (data2.allowTouchCallbacks) {
      swiper2.emit("touchEnd", e);
    }
    data2.allowTouchCallbacks = false;
    if (!data2.isTouched) {
      if (data2.isMoved && params.grabCursor) {
        swiper2.setGrabCursor(false);
      }
      data2.isMoved = false;
      data2.startMoving = false;
      return;
    }
    if (params.grabCursor && data2.isMoved && data2.isTouched && (swiper2.allowSlideNext === true || swiper2.allowSlidePrev === true)) {
      swiper2.setGrabCursor(false);
    }
    const touchEndTime = now();
    const timeDiff = touchEndTime - data2.touchStartTime;
    if (swiper2.allowClick) {
      const pathTree = e.path || e.composedPath && e.composedPath();
      swiper2.updateClickedSlide(pathTree && pathTree[0] || e.target);
      swiper2.emit("tap click", e);
      if (timeDiff < 300 && touchEndTime - data2.lastClickTime < 300) {
        swiper2.emit("doubleTap doubleClick", e);
      }
    }
    data2.lastClickTime = now();
    nextTick(() => {
      if (!swiper2.destroyed) swiper2.allowClick = true;
    });
    if (!data2.isTouched || !data2.isMoved || !swiper2.swipeDirection || touches.diff === 0 || data2.currentTranslate === data2.startTranslate) {
      data2.isTouched = false;
      data2.isMoved = false;
      data2.startMoving = false;
      return;
    }
    data2.isTouched = false;
    data2.isMoved = false;
    data2.startMoving = false;
    let currentPos;
    if (params.followFinger) {
      currentPos = rtl ? swiper2.translate : -swiper2.translate;
    } else {
      currentPos = -data2.currentTranslate;
    }
    if (params.cssMode) {
      return;
    }
    if (swiper2.params.freeMode && params.freeMode.enabled) {
      swiper2.freeMode.onTouchEnd({
        currentPos
      });
      return;
    }
    let stopIndex = 0;
    let groupSize = swiper2.slidesSizesGrid[0];
    for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
      const increment2 = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
      if (typeof slidesGrid[i + increment2] !== "undefined") {
        if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment2]) {
          stopIndex = i;
          groupSize = slidesGrid[i + increment2] - slidesGrid[i];
        }
      } else if (currentPos >= slidesGrid[i]) {
        stopIndex = i;
        groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
      }
    }
    let rewindFirstIndex = null;
    let rewindLastIndex = null;
    if (params.rewind) {
      if (swiper2.isBeginning) {
        rewindLastIndex = swiper2.params.virtual && swiper2.params.virtual.enabled && swiper2.virtual ? swiper2.virtual.slides.length - 1 : swiper2.slides.length - 1;
      } else if (swiper2.isEnd) {
        rewindFirstIndex = 0;
      }
    }
    const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
    const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (timeDiff > params.longSwipesMs) {
      if (!params.longSwipes) {
        swiper2.slideTo(swiper2.activeIndex);
        return;
      }
      if (swiper2.swipeDirection === "next") {
        if (ratio >= params.longSwipesRatio) swiper2.slideTo(params.rewind && swiper2.isEnd ? rewindFirstIndex : stopIndex + increment);
        else swiper2.slideTo(stopIndex);
      }
      if (swiper2.swipeDirection === "prev") {
        if (ratio > 1 - params.longSwipesRatio) {
          swiper2.slideTo(stopIndex + increment);
        } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
          swiper2.slideTo(rewindLastIndex);
        } else {
          swiper2.slideTo(stopIndex);
        }
      }
    } else {
      if (!params.shortSwipes) {
        swiper2.slideTo(swiper2.activeIndex);
        return;
      }
      const isNavButtonTarget = swiper2.navigation && (e.target === swiper2.navigation.nextEl || e.target === swiper2.navigation.prevEl);
      if (!isNavButtonTarget) {
        if (swiper2.swipeDirection === "next") {
          swiper2.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
        }
        if (swiper2.swipeDirection === "prev") {
          swiper2.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
        }
      } else if (e.target === swiper2.navigation.nextEl) {
        swiper2.slideTo(stopIndex + increment);
      } else {
        swiper2.slideTo(stopIndex);
      }
    }
  }

  // node_modules/swiper/core/events/onResize.js
  function onResize() {
    const swiper2 = this;
    const {
      params,
      el
    } = swiper2;
    if (el && el.offsetWidth === 0) return;
    if (params.breakpoints) {
      swiper2.setBreakpoint();
    }
    const {
      allowSlideNext,
      allowSlidePrev,
      snapGrid
    } = swiper2;
    swiper2.allowSlideNext = true;
    swiper2.allowSlidePrev = true;
    swiper2.updateSize();
    swiper2.updateSlides();
    swiper2.updateSlidesClasses();
    if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper2.isEnd && !swiper2.isBeginning && !swiper2.params.centeredSlides) {
      swiper2.slideTo(swiper2.slides.length - 1, 0, false, true);
    } else {
      swiper2.slideTo(swiper2.activeIndex, 0, false, true);
    }
    if (swiper2.autoplay && swiper2.autoplay.running && swiper2.autoplay.paused) {
      swiper2.autoplay.run();
    }
    swiper2.allowSlidePrev = allowSlidePrev;
    swiper2.allowSlideNext = allowSlideNext;
    if (swiper2.params.watchOverflow && snapGrid !== swiper2.snapGrid) {
      swiper2.checkOverflow();
    }
  }

  // node_modules/swiper/core/events/onClick.js
  function onClick(e) {
    const swiper2 = this;
    if (!swiper2.enabled) return;
    if (!swiper2.allowClick) {
      if (swiper2.params.preventClicks) e.preventDefault();
      if (swiper2.params.preventClicksPropagation && swiper2.animating) {
        e.stopPropagation();
        e.stopImmediatePropagation();
      }
    }
  }

  // node_modules/swiper/core/events/onScroll.js
  function onScroll() {
    const swiper2 = this;
    const {
      wrapperEl,
      rtlTranslate,
      enabled
    } = swiper2;
    if (!enabled) return;
    swiper2.previousTranslate = swiper2.translate;
    if (swiper2.isHorizontal()) {
      swiper2.translate = -wrapperEl.scrollLeft;
    } else {
      swiper2.translate = -wrapperEl.scrollTop;
    }
    if (swiper2.translate === 0) swiper2.translate = 0;
    swiper2.updateActiveIndex();
    swiper2.updateSlidesClasses();
    let newProgress;
    const translatesDiff = swiper2.maxTranslate() - swiper2.minTranslate();
    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (swiper2.translate - swiper2.minTranslate()) / translatesDiff;
    }
    if (newProgress !== swiper2.progress) {
      swiper2.updateProgress(rtlTranslate ? -swiper2.translate : swiper2.translate);
    }
    swiper2.emit("setTranslate", swiper2.translate, false);
  }

  // node_modules/swiper/core/events/index.js
  var dummyEventAttached = false;
  function dummyEventListener() {
  }
  var events = (swiper2, method) => {
    const document2 = getDocument();
    const {
      params,
      touchEvents,
      el,
      wrapperEl,
      device,
      support: support2
    } = swiper2;
    const capture = !!params.nested;
    const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
    const swiperMethod = method;
    if (!support2.touch) {
      el[domMethod](touchEvents.start, swiper2.onTouchStart, false);
      document2[domMethod](touchEvents.move, swiper2.onTouchMove, capture);
      document2[domMethod](touchEvents.end, swiper2.onTouchEnd, false);
    } else {
      const passiveListener = touchEvents.start === "touchstart" && support2.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      el[domMethod](touchEvents.start, swiper2.onTouchStart, passiveListener);
      el[domMethod](touchEvents.move, swiper2.onTouchMove, support2.passiveListener ? {
        passive: false,
        capture
      } : capture);
      el[domMethod](touchEvents.end, swiper2.onTouchEnd, passiveListener);
      if (touchEvents.cancel) {
        el[domMethod](touchEvents.cancel, swiper2.onTouchEnd, passiveListener);
      }
    }
    if (params.preventClicks || params.preventClicksPropagation) {
      el[domMethod]("click", swiper2.onClick, true);
    }
    if (params.cssMode) {
      wrapperEl[domMethod]("scroll", swiper2.onScroll);
    }
    if (params.updateOnWindowResize) {
      swiper2[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
    } else {
      swiper2[swiperMethod]("observerUpdate", onResize, true);
    }
  };
  function attachEvents() {
    const swiper2 = this;
    const document2 = getDocument();
    const {
      params,
      support: support2
    } = swiper2;
    swiper2.onTouchStart = onTouchStart.bind(swiper2);
    swiper2.onTouchMove = onTouchMove.bind(swiper2);
    swiper2.onTouchEnd = onTouchEnd.bind(swiper2);
    if (params.cssMode) {
      swiper2.onScroll = onScroll.bind(swiper2);
    }
    swiper2.onClick = onClick.bind(swiper2);
    if (support2.touch && !dummyEventAttached) {
      document2.addEventListener("touchstart", dummyEventListener);
      dummyEventAttached = true;
    }
    events(swiper2, "on");
  }
  function detachEvents() {
    const swiper2 = this;
    events(swiper2, "off");
  }
  var events_default = {
    attachEvents,
    detachEvents
  };

  // node_modules/swiper/core/breakpoints/setBreakpoint.js
  var isGridEnabled = (swiper2, params) => {
    return swiper2.grid && params.grid && params.grid.rows > 1;
  };
  function setBreakpoint() {
    const swiper2 = this;
    const {
      activeIndex,
      initialized,
      loopedSlides = 0,
      params,
      $el
    } = swiper2;
    const breakpoints = params.breakpoints;
    if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;
    const breakpoint = swiper2.getBreakpoint(breakpoints, swiper2.params.breakpointsBase, swiper2.el);
    if (!breakpoint || swiper2.currentBreakpoint === breakpoint) return;
    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : void 0;
    const breakpointParams = breakpointOnlyParams || swiper2.originalParams;
    const wasMultiRow = isGridEnabled(swiper2, params);
    const isMultiRow = isGridEnabled(swiper2, breakpointParams);
    const wasEnabled = params.enabled;
    if (wasMultiRow && !isMultiRow) {
      $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);
      swiper2.emitContainerClasses();
    } else if (!wasMultiRow && isMultiRow) {
      $el.addClass(`${params.containerModifierClass}grid`);
      if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") {
        $el.addClass(`${params.containerModifierClass}grid-column`);
      }
      swiper2.emitContainerClasses();
    }
    ["navigation", "pagination", "scrollbar"].forEach((prop) => {
      const wasModuleEnabled = params[prop] && params[prop].enabled;
      const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
      if (wasModuleEnabled && !isModuleEnabled) {
        swiper2[prop].disable();
      }
      if (!wasModuleEnabled && isModuleEnabled) {
        swiper2[prop].enable();
      }
    });
    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
    if (directionChanged && initialized) {
      swiper2.changeDirection();
    }
    extend2(swiper2.params, breakpointParams);
    const isEnabled = swiper2.params.enabled;
    Object.assign(swiper2, {
      allowTouchMove: swiper2.params.allowTouchMove,
      allowSlideNext: swiper2.params.allowSlideNext,
      allowSlidePrev: swiper2.params.allowSlidePrev
    });
    if (wasEnabled && !isEnabled) {
      swiper2.disable();
    } else if (!wasEnabled && isEnabled) {
      swiper2.enable();
    }
    swiper2.currentBreakpoint = breakpoint;
    swiper2.emit("_beforeBreakpoint", breakpointParams);
    if (needsReLoop && initialized) {
      swiper2.loopDestroy();
      swiper2.loopCreate();
      swiper2.updateSlides();
      swiper2.slideTo(activeIndex - loopedSlides + swiper2.loopedSlides, 0, false);
    }
    swiper2.emit("breakpoint", breakpointParams);
  }

  // node_modules/swiper/core/breakpoints/getBreakpoint.js
  function getBreakpoint(breakpoints, base = "window", containerEl) {
    if (!breakpoints || base === "container" && !containerEl) return void 0;
    let breakpoint = false;
    const window2 = getWindow();
    const currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight;
    const points = Object.keys(breakpoints).map((point) => {
      if (typeof point === "string" && point.indexOf("@") === 0) {
        const minRatio = parseFloat(point.substr(1));
        const value = currentHeight * minRatio;
        return {
          value,
          point
        };
      }
      return {
        value: point,
        point
      };
    });
    points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
    for (let i = 0; i < points.length; i += 1) {
      const {
        point,
        value
      } = points[i];
      if (base === "window") {
        if (window2.matchMedia(`(min-width: ${value}px)`).matches) {
          breakpoint = point;
        }
      } else if (value <= containerEl.clientWidth) {
        breakpoint = point;
      }
    }
    return breakpoint || "max";
  }

  // node_modules/swiper/core/breakpoints/index.js
  var breakpoints_default = {
    setBreakpoint,
    getBreakpoint
  };

  // node_modules/swiper/core/classes/addClasses.js
  function prepareClasses(entries, prefix) {
    const resultClasses = [];
    entries.forEach((item) => {
      if (typeof item === "object") {
        Object.keys(item).forEach((classNames) => {
          if (item[classNames]) {
            resultClasses.push(prefix + classNames);
          }
        });
      } else if (typeof item === "string") {
        resultClasses.push(prefix + item);
      }
    });
    return resultClasses;
  }
  function addClasses() {
    const swiper2 = this;
    const {
      classNames,
      params,
      rtl,
      $el,
      device,
      support: support2
    } = swiper2;
    const suffixes = prepareClasses(["initialized", params.direction, {
      "pointer-events": !support2.touch
    }, {
      "free-mode": swiper2.params.freeMode && params.freeMode.enabled
    }, {
      "autoheight": params.autoHeight
    }, {
      "rtl": rtl
    }, {
      "grid": params.grid && params.grid.rows > 1
    }, {
      "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
    }, {
      "android": device.android
    }, {
      "ios": device.ios
    }, {
      "css-mode": params.cssMode
    }, {
      "centered": params.cssMode && params.centeredSlides
    }, {
      "watch-progress": params.watchSlidesProgress
    }], params.containerModifierClass);
    classNames.push(...suffixes);
    $el.addClass([...classNames].join(" "));
    swiper2.emitContainerClasses();
  }

  // node_modules/swiper/core/classes/removeClasses.js
  function removeClasses() {
    const swiper2 = this;
    const {
      $el,
      classNames
    } = swiper2;
    $el.removeClass(classNames.join(" "));
    swiper2.emitContainerClasses();
  }

  // node_modules/swiper/core/classes/index.js
  var classes_default = {
    addClasses,
    removeClasses
  };

  // node_modules/swiper/core/images/loadImage.js
  function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
    const window2 = getWindow();
    let image;
    function onReady() {
      if (callback) callback();
    }
    const isPicture = dom_default(imageEl).parent("picture")[0];
    if (!isPicture && (!imageEl.complete || !checkForComplete)) {
      if (src) {
        image = new window2.Image();
        image.onload = onReady;
        image.onerror = onReady;
        if (sizes) {
          image.sizes = sizes;
        }
        if (srcset) {
          image.srcset = srcset;
        }
        if (src) {
          image.src = src;
        }
      } else {
        onReady();
      }
    } else {
      onReady();
    }
  }

  // node_modules/swiper/core/images/preloadImages.js
  function preloadImages() {
    const swiper2 = this;
    swiper2.imagesToLoad = swiper2.$el.find("img");
    function onReady() {
      if (typeof swiper2 === "undefined" || swiper2 === null || !swiper2 || swiper2.destroyed) return;
      if (swiper2.imagesLoaded !== void 0) swiper2.imagesLoaded += 1;
      if (swiper2.imagesLoaded === swiper2.imagesToLoad.length) {
        if (swiper2.params.updateOnImagesReady) swiper2.update();
        swiper2.emit("imagesReady");
      }
    }
    for (let i = 0; i < swiper2.imagesToLoad.length; i += 1) {
      const imageEl = swiper2.imagesToLoad[i];
      swiper2.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute("src"), imageEl.srcset || imageEl.getAttribute("srcset"), imageEl.sizes || imageEl.getAttribute("sizes"), true, onReady);
    }
  }

  // node_modules/swiper/core/images/index.js
  var images_default = {
    loadImage,
    preloadImages
  };

  // node_modules/swiper/core/check-overflow/index.js
  function checkOverflow() {
    const swiper2 = this;
    const {
      isLocked: wasLocked,
      params
    } = swiper2;
    const {
      slidesOffsetBefore
    } = params;
    if (slidesOffsetBefore) {
      const lastSlideIndex = swiper2.slides.length - 1;
      const lastSlideRightEdge = swiper2.slidesGrid[lastSlideIndex] + swiper2.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
      swiper2.isLocked = swiper2.size > lastSlideRightEdge;
    } else {
      swiper2.isLocked = swiper2.snapGrid.length === 1;
    }
    if (params.allowSlideNext === true) {
      swiper2.allowSlideNext = !swiper2.isLocked;
    }
    if (params.allowSlidePrev === true) {
      swiper2.allowSlidePrev = !swiper2.isLocked;
    }
    if (wasLocked && wasLocked !== swiper2.isLocked) {
      swiper2.isEnd = false;
    }
    if (wasLocked !== swiper2.isLocked) {
      swiper2.emit(swiper2.isLocked ? "lock" : "unlock");
    }
  }
  var check_overflow_default = {
    checkOverflow
  };

  // node_modules/swiper/core/defaults.js
  var defaults_default = {
    init: true,
    direction: "horizontal",
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: false,
    updateOnWindowResize: true,
    resizeObserver: true,
    nested: false,
    createElements: false,
    enabled: true,
    focusableElements: "input, select, option, textarea, button, video, label",
    // Overrides
    width: null,
    height: null,
    //
    preventInteractionOnTransition: false,
    // ssr
    userAgent: null,
    url: null,
    // To support iOS's swipe-to-go-back gesture (when being used in-app).
    edgeSwipeDetection: false,
    edgeSwipeThreshold: 20,
    // Autoheight
    autoHeight: false,
    // Set wrapper width
    setWrapperSize: false,
    // Virtual Translate
    virtualTranslate: false,
    // Effects
    effect: "slide",
    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
    // Breakpoints
    breakpoints: void 0,
    breakpointsBase: "window",
    // Slides grid
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: false,
    centeredSlides: false,
    centeredSlidesBounds: false,
    slidesOffsetBefore: 0,
    // in px
    slidesOffsetAfter: 0,
    // in px
    normalizeSlideIndex: true,
    centerInsufficientSlides: false,
    // Disable swiper and hide navigation when container not overflow
    watchOverflow: true,
    // Round length
    roundLengths: false,
    // Touches
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: true,
    shortSwipes: true,
    longSwipes: true,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: true,
    allowTouchMove: true,
    threshold: 0,
    touchMoveStopPropagation: false,
    touchStartPreventDefault: true,
    touchStartForcePreventDefault: false,
    touchReleaseOnEdges: false,
    // Unique Navigation Elements
    uniqueNavElements: true,
    // Resistance
    resistance: true,
    resistanceRatio: 0.85,
    // Progress
    watchSlidesProgress: false,
    // Cursor
    grabCursor: false,
    // Clicks
    preventClicks: true,
    preventClicksPropagation: true,
    slideToClickedSlide: false,
    // Images
    preloadImages: true,
    updateOnImagesReady: true,
    // loop
    loop: false,
    loopAdditionalSlides: 0,
    loopedSlides: null,
    loopedSlidesLimit: true,
    loopFillGroupWithBlank: false,
    loopPreventsSlide: true,
    // rewind
    rewind: false,
    // Swiping/no swiping
    allowSlidePrev: true,
    allowSlideNext: true,
    swipeHandler: null,
    // '.swipe-handler',
    noSwiping: true,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    // Passive Listeners
    passiveListeners: true,
    maxBackfaceHiddenSlides: 10,
    // NS
    containerModifierClass: "swiper-",
    // NEW
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-invisible-blank",
    slideActiveClass: "swiper-slide-active",
    slideDuplicateActiveClass: "swiper-slide-duplicate-active",
    slideVisibleClass: "swiper-slide-visible",
    slideDuplicateClass: "swiper-slide-duplicate",
    slideNextClass: "swiper-slide-next",
    slideDuplicateNextClass: "swiper-slide-duplicate-next",
    slidePrevClass: "swiper-slide-prev",
    slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
    wrapperClass: "swiper-wrapper",
    // Callbacks
    runCallbacksOnInit: true,
    // Internals
    _emitClasses: false
  };

  // node_modules/swiper/core/moduleExtendParams.js
  function moduleExtendParams(params, allModulesParams) {
    return function extendParams(obj = {}) {
      const moduleParamName = Object.keys(obj)[0];
      const moduleParams = obj[moduleParamName];
      if (typeof moduleParams !== "object" || moduleParams === null) {
        extend2(allModulesParams, obj);
        return;
      }
      if (["navigation", "pagination", "scrollbar"].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
        params[moduleParamName] = {
          auto: true
        };
      }
      if (!(moduleParamName in params && "enabled" in moduleParams)) {
        extend2(allModulesParams, obj);
        return;
      }
      if (params[moduleParamName] === true) {
        params[moduleParamName] = {
          enabled: true
        };
      }
      if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
        params[moduleParamName].enabled = true;
      }
      if (!params[moduleParamName]) params[moduleParamName] = {
        enabled: false
      };
      extend2(allModulesParams, obj);
    };
  }

  // node_modules/swiper/core/core.js
  var prototypes = {
    eventsEmitter: events_emitter_default,
    update: update_default,
    translate: translate_default,
    transition: transition_default,
    slide: slide_default,
    loop: loop_default,
    grabCursor: grab_cursor_default,
    events: events_default,
    breakpoints: breakpoints_default,
    checkOverflow: check_overflow_default,
    classes: classes_default,
    images: images_default
  };
  var extendedDefaults = {};
  var Swiper = class _Swiper {
    constructor(...args) {
      let el;
      let params;
      if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
        params = args[0];
      } else {
        [el, params] = args;
      }
      if (!params) params = {};
      params = extend2({}, params);
      if (el && !params.el) params.el = el;
      if (params.el && dom_default(params.el).length > 1) {
        const swipers = [];
        dom_default(params.el).each((containerEl) => {
          const newParams = extend2({}, params, {
            el: containerEl
          });
          swipers.push(new _Swiper(newParams));
        });
        return swipers;
      }
      const swiper2 = this;
      swiper2.__swiper__ = true;
      swiper2.support = getSupport();
      swiper2.device = getDevice({
        userAgent: params.userAgent
      });
      swiper2.browser = getBrowser();
      swiper2.eventsListeners = {};
      swiper2.eventsAnyListeners = [];
      swiper2.modules = [...swiper2.__modules__];
      if (params.modules && Array.isArray(params.modules)) {
        swiper2.modules.push(...params.modules);
      }
      const allModulesParams = {};
      swiper2.modules.forEach((mod) => {
        mod({
          swiper: swiper2,
          extendParams: moduleExtendParams(params, allModulesParams),
          on: swiper2.on.bind(swiper2),
          once: swiper2.once.bind(swiper2),
          off: swiper2.off.bind(swiper2),
          emit: swiper2.emit.bind(swiper2)
        });
      });
      const swiperParams = extend2({}, defaults_default, allModulesParams);
      swiper2.params = extend2({}, swiperParams, extendedDefaults, params);
      swiper2.originalParams = extend2({}, swiper2.params);
      swiper2.passedParams = extend2({}, params);
      if (swiper2.params && swiper2.params.on) {
        Object.keys(swiper2.params.on).forEach((eventName) => {
          swiper2.on(eventName, swiper2.params.on[eventName]);
        });
      }
      if (swiper2.params && swiper2.params.onAny) {
        swiper2.onAny(swiper2.params.onAny);
      }
      swiper2.$ = dom_default;
      Object.assign(swiper2, {
        enabled: swiper2.params.enabled,
        el,
        // Classes
        classNames: [],
        // Slides
        slides: dom_default(),
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],
        // isDirection
        isHorizontal() {
          return swiper2.params.direction === "horizontal";
        },
        isVertical() {
          return swiper2.params.direction === "vertical";
        },
        // Indexes
        activeIndex: 0,
        realIndex: 0,
        //
        isBeginning: true,
        isEnd: false,
        // Props
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: false,
        // Locks
        allowSlideNext: swiper2.params.allowSlideNext,
        allowSlidePrev: swiper2.params.allowSlidePrev,
        // Touch Events
        touchEvents: function touchEvents() {
          const touch = ["touchstart", "touchmove", "touchend", "touchcancel"];
          const desktop = ["pointerdown", "pointermove", "pointerup"];
          swiper2.touchEventsTouch = {
            start: touch[0],
            move: touch[1],
            end: touch[2],
            cancel: touch[3]
          };
          swiper2.touchEventsDesktop = {
            start: desktop[0],
            move: desktop[1],
            end: desktop[2]
          };
          return swiper2.support.touch || !swiper2.params.simulateTouch ? swiper2.touchEventsTouch : swiper2.touchEventsDesktop;
        }(),
        touchEventsData: {
          isTouched: void 0,
          isMoved: void 0,
          allowTouchCallbacks: void 0,
          touchStartTime: void 0,
          isScrolling: void 0,
          currentTranslate: void 0,
          startTranslate: void 0,
          allowThresholdMove: void 0,
          // Form elements to match
          focusableElements: swiper2.params.focusableElements,
          // Last click time
          lastClickTime: now(),
          clickTimeout: void 0,
          // Velocities
          velocities: [],
          allowMomentumBounce: void 0,
          isTouchEvent: void 0,
          startMoving: void 0
        },
        // Clicks
        allowClick: true,
        // Touches
        allowTouchMove: swiper2.params.allowTouchMove,
        touches: {
          startX: 0,
          startY: 0,
          currentX: 0,
          currentY: 0,
          diff: 0
        },
        // Images
        imagesToLoad: [],
        imagesLoaded: 0
      });
      swiper2.emit("_swiper");
      if (swiper2.params.init) {
        swiper2.init();
      }
      return swiper2;
    }
    enable() {
      const swiper2 = this;
      if (swiper2.enabled) return;
      swiper2.enabled = true;
      if (swiper2.params.grabCursor) {
        swiper2.setGrabCursor();
      }
      swiper2.emit("enable");
    }
    disable() {
      const swiper2 = this;
      if (!swiper2.enabled) return;
      swiper2.enabled = false;
      if (swiper2.params.grabCursor) {
        swiper2.unsetGrabCursor();
      }
      swiper2.emit("disable");
    }
    setProgress(progress, speed) {
      const swiper2 = this;
      progress = Math.min(Math.max(progress, 0), 1);
      const min = swiper2.minTranslate();
      const max = swiper2.maxTranslate();
      const current = (max - min) * progress + min;
      swiper2.translateTo(current, typeof speed === "undefined" ? 0 : speed);
      swiper2.updateActiveIndex();
      swiper2.updateSlidesClasses();
    }
    emitContainerClasses() {
      const swiper2 = this;
      if (!swiper2.params._emitClasses || !swiper2.el) return;
      const cls = swiper2.el.className.split(" ").filter((className) => {
        return className.indexOf("swiper") === 0 || className.indexOf(swiper2.params.containerModifierClass) === 0;
      });
      swiper2.emit("_containerClasses", cls.join(" "));
    }
    getSlideClasses(slideEl) {
      const swiper2 = this;
      if (swiper2.destroyed) return "";
      return slideEl.className.split(" ").filter((className) => {
        return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper2.params.slideClass) === 0;
      }).join(" ");
    }
    emitSlidesClasses() {
      const swiper2 = this;
      if (!swiper2.params._emitClasses || !swiper2.el) return;
      const updates = [];
      swiper2.slides.each((slideEl) => {
        const classNames = swiper2.getSlideClasses(slideEl);
        updates.push({
          slideEl,
          classNames
        });
        swiper2.emit("_slideClass", slideEl, classNames);
      });
      swiper2.emit("_slideClasses", updates);
    }
    slidesPerViewDynamic(view = "current", exact = false) {
      const swiper2 = this;
      const {
        params,
        slides,
        slidesGrid,
        slidesSizesGrid,
        size: swiperSize,
        activeIndex
      } = swiper2;
      let spv = 1;
      if (params.centeredSlides) {
        let slideSize = slides[activeIndex].swiperSlideSize;
        let breakLoop;
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          if (slides[i] && !breakLoop) {
            slideSize += slides[i].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize) breakLoop = true;
          }
        }
        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          if (slides[i] && !breakLoop) {
            slideSize += slides[i].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize) breakLoop = true;
          }
        }
      } else {
        if (view === "current") {
          for (let i = activeIndex + 1; i < slides.length; i += 1) {
            const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
            if (slideInView) {
              spv += 1;
            }
          }
        } else {
          for (let i = activeIndex - 1; i >= 0; i -= 1) {
            const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
            if (slideInView) {
              spv += 1;
            }
          }
        }
      }
      return spv;
    }
    update() {
      const swiper2 = this;
      if (!swiper2 || swiper2.destroyed) return;
      const {
        snapGrid,
        params
      } = swiper2;
      if (params.breakpoints) {
        swiper2.setBreakpoint();
      }
      swiper2.updateSize();
      swiper2.updateSlides();
      swiper2.updateProgress();
      swiper2.updateSlidesClasses();
      function setTranslate2() {
        const translateValue = swiper2.rtlTranslate ? swiper2.translate * -1 : swiper2.translate;
        const newTranslate = Math.min(Math.max(translateValue, swiper2.maxTranslate()), swiper2.minTranslate());
        swiper2.setTranslate(newTranslate);
        swiper2.updateActiveIndex();
        swiper2.updateSlidesClasses();
      }
      let translated;
      if (swiper2.params.freeMode && swiper2.params.freeMode.enabled) {
        setTranslate2();
        if (swiper2.params.autoHeight) {
          swiper2.updateAutoHeight();
        }
      } else {
        if ((swiper2.params.slidesPerView === "auto" || swiper2.params.slidesPerView > 1) && swiper2.isEnd && !swiper2.params.centeredSlides) {
          translated = swiper2.slideTo(swiper2.slides.length - 1, 0, false, true);
        } else {
          translated = swiper2.slideTo(swiper2.activeIndex, 0, false, true);
        }
        if (!translated) {
          setTranslate2();
        }
      }
      if (params.watchOverflow && snapGrid !== swiper2.snapGrid) {
        swiper2.checkOverflow();
      }
      swiper2.emit("update");
    }
    changeDirection(newDirection, needUpdate = true) {
      const swiper2 = this;
      const currentDirection = swiper2.params.direction;
      if (!newDirection) {
        newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
      }
      if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
        return swiper2;
      }
      swiper2.$el.removeClass(`${swiper2.params.containerModifierClass}${currentDirection}`).addClass(`${swiper2.params.containerModifierClass}${newDirection}`);
      swiper2.emitContainerClasses();
      swiper2.params.direction = newDirection;
      swiper2.slides.each((slideEl) => {
        if (newDirection === "vertical") {
          slideEl.style.width = "";
        } else {
          slideEl.style.height = "";
        }
      });
      swiper2.emit("changeDirection");
      if (needUpdate) swiper2.update();
      return swiper2;
    }
    changeLanguageDirection(direction) {
      const swiper2 = this;
      if (swiper2.rtl && direction === "rtl" || !swiper2.rtl && direction === "ltr") return;
      swiper2.rtl = direction === "rtl";
      swiper2.rtlTranslate = swiper2.params.direction === "horizontal" && swiper2.rtl;
      if (swiper2.rtl) {
        swiper2.$el.addClass(`${swiper2.params.containerModifierClass}rtl`);
        swiper2.el.dir = "rtl";
      } else {
        swiper2.$el.removeClass(`${swiper2.params.containerModifierClass}rtl`);
        swiper2.el.dir = "ltr";
      }
      swiper2.update();
    }
    mount(el) {
      const swiper2 = this;
      if (swiper2.mounted) return true;
      const $el = dom_default(el || swiper2.params.el);
      el = $el[0];
      if (!el) {
        return false;
      }
      el.swiper = swiper2;
      const getWrapperSelector = () => {
        return `.${(swiper2.params.wrapperClass || "").trim().split(" ").join(".")}`;
      };
      const getWrapper = () => {
        if (el && el.shadowRoot && el.shadowRoot.querySelector) {
          const res = dom_default(el.shadowRoot.querySelector(getWrapperSelector()));
          res.children = (options) => $el.children(options);
          return res;
        }
        if (!$el.children) {
          return dom_default($el).children(getWrapperSelector());
        }
        return $el.children(getWrapperSelector());
      };
      let $wrapperEl = getWrapper();
      if ($wrapperEl.length === 0 && swiper2.params.createElements) {
        const document2 = getDocument();
        const wrapper = document2.createElement("div");
        $wrapperEl = dom_default(wrapper);
        wrapper.className = swiper2.params.wrapperClass;
        $el.append(wrapper);
        $el.children(`.${swiper2.params.slideClass}`).each((slideEl) => {
          $wrapperEl.append(slideEl);
        });
      }
      Object.assign(swiper2, {
        $el,
        el,
        $wrapperEl,
        wrapperEl: $wrapperEl[0],
        mounted: true,
        // RTL
        rtl: el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl",
        rtlTranslate: swiper2.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl"),
        wrongRTL: $wrapperEl.css("display") === "-webkit-box"
      });
      return true;
    }
    init(el) {
      const swiper2 = this;
      if (swiper2.initialized) return swiper2;
      const mounted = swiper2.mount(el);
      if (mounted === false) return swiper2;
      swiper2.emit("beforeInit");
      if (swiper2.params.breakpoints) {
        swiper2.setBreakpoint();
      }
      swiper2.addClasses();
      if (swiper2.params.loop) {
        swiper2.loopCreate();
      }
      swiper2.updateSize();
      swiper2.updateSlides();
      if (swiper2.params.watchOverflow) {
        swiper2.checkOverflow();
      }
      if (swiper2.params.grabCursor && swiper2.enabled) {
        swiper2.setGrabCursor();
      }
      if (swiper2.params.preloadImages) {
        swiper2.preloadImages();
      }
      if (swiper2.params.loop) {
        swiper2.slideTo(swiper2.params.initialSlide + swiper2.loopedSlides, 0, swiper2.params.runCallbacksOnInit, false, true);
      } else {
        swiper2.slideTo(swiper2.params.initialSlide, 0, swiper2.params.runCallbacksOnInit, false, true);
      }
      swiper2.attachEvents();
      swiper2.initialized = true;
      swiper2.emit("init");
      swiper2.emit("afterInit");
      return swiper2;
    }
    destroy(deleteInstance = true, cleanStyles = true) {
      const swiper2 = this;
      const {
        params,
        $el,
        $wrapperEl,
        slides
      } = swiper2;
      if (typeof swiper2.params === "undefined" || swiper2.destroyed) {
        return null;
      }
      swiper2.emit("beforeDestroy");
      swiper2.initialized = false;
      swiper2.detachEvents();
      if (params.loop) {
        swiper2.loopDestroy();
      }
      if (cleanStyles) {
        swiper2.removeClasses();
        $el.removeAttr("style");
        $wrapperEl.removeAttr("style");
        if (slides && slides.length) {
          slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index");
        }
      }
      swiper2.emit("destroy");
      Object.keys(swiper2.eventsListeners).forEach((eventName) => {
        swiper2.off(eventName);
      });
      if (deleteInstance !== false) {
        swiper2.$el[0].swiper = null;
        deleteProps(swiper2);
      }
      swiper2.destroyed = true;
      return null;
    }
    static extendDefaults(newDefaults) {
      extend2(extendedDefaults, newDefaults);
    }
    static get extendedDefaults() {
      return extendedDefaults;
    }
    static get defaults() {
      return defaults_default;
    }
    static installModule(mod) {
      if (!_Swiper.prototype.__modules__) _Swiper.prototype.__modules__ = [];
      const modules = _Swiper.prototype.__modules__;
      if (typeof mod === "function" && modules.indexOf(mod) < 0) {
        modules.push(mod);
      }
    }
    static use(module) {
      if (Array.isArray(module)) {
        module.forEach((m) => _Swiper.installModule(m));
        return _Swiper;
      }
      _Swiper.installModule(module);
      return _Swiper;
    }
  };
  Object.keys(prototypes).forEach((prototypeGroup) => {
    Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
      Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
    });
  });
  Swiper.use([Resize, Observer]);
  var core_default = Swiper;

  // node_modules/swiper/shared/create-element-if-not-defined.js
  function createElementIfNotDefined(swiper2, originalParams, params, checkProps) {
    const document2 = getDocument();
    if (swiper2.params.createElements) {
      Object.keys(checkProps).forEach((key) => {
        if (!params[key] && params.auto === true) {
          let element = swiper2.$el.children(`.${checkProps[key]}`)[0];
          if (!element) {
            element = document2.createElement("div");
            element.className = checkProps[key];
            swiper2.$el.append(element);
          }
          params[key] = element;
          originalParams[key] = element;
        }
      });
    }
    return params;
  }

  // node_modules/swiper/modules/navigation/navigation.js
  function Navigation({
    swiper: swiper2,
    extendParams,
    on: on2,
    emit
  }) {
    extendParams({
      navigation: {
        nextEl: null,
        prevEl: null,
        hideOnClick: false,
        disabledClass: "swiper-button-disabled",
        hiddenClass: "swiper-button-hidden",
        lockClass: "swiper-button-lock",
        navigationDisabledClass: "swiper-navigation-disabled"
      }
    });
    swiper2.navigation = {
      nextEl: null,
      $nextEl: null,
      prevEl: null,
      $prevEl: null
    };
    function getEl(el) {
      let $el;
      if (el) {
        $el = dom_default(el);
        if (swiper2.params.uniqueNavElements && typeof el === "string" && $el.length > 1 && swiper2.$el.find(el).length === 1) {
          $el = swiper2.$el.find(el);
        }
      }
      return $el;
    }
    function toggleEl($el, disabled) {
      const params = swiper2.params.navigation;
      if ($el && $el.length > 0) {
        $el[disabled ? "addClass" : "removeClass"](params.disabledClass);
        if ($el[0] && $el[0].tagName === "BUTTON") $el[0].disabled = disabled;
        if (swiper2.params.watchOverflow && swiper2.enabled) {
          $el[swiper2.isLocked ? "addClass" : "removeClass"](params.lockClass);
        }
      }
    }
    function update() {
      if (swiper2.params.loop) return;
      const {
        $nextEl,
        $prevEl
      } = swiper2.navigation;
      toggleEl($prevEl, swiper2.isBeginning && !swiper2.params.rewind);
      toggleEl($nextEl, swiper2.isEnd && !swiper2.params.rewind);
    }
    function onPrevClick(e) {
      e.preventDefault();
      if (swiper2.isBeginning && !swiper2.params.loop && !swiper2.params.rewind) return;
      swiper2.slidePrev();
      emit("navigationPrev");
    }
    function onNextClick(e) {
      e.preventDefault();
      if (swiper2.isEnd && !swiper2.params.loop && !swiper2.params.rewind) return;
      swiper2.slideNext();
      emit("navigationNext");
    }
    function init() {
      const params = swiper2.params.navigation;
      swiper2.params.navigation = createElementIfNotDefined(swiper2, swiper2.originalParams.navigation, swiper2.params.navigation, {
        nextEl: "swiper-button-next",
        prevEl: "swiper-button-prev"
      });
      if (!(params.nextEl || params.prevEl)) return;
      const $nextEl = getEl(params.nextEl);
      const $prevEl = getEl(params.prevEl);
      if ($nextEl && $nextEl.length > 0) {
        $nextEl.on("click", onNextClick);
      }
      if ($prevEl && $prevEl.length > 0) {
        $prevEl.on("click", onPrevClick);
      }
      Object.assign(swiper2.navigation, {
        $nextEl,
        nextEl: $nextEl && $nextEl[0],
        $prevEl,
        prevEl: $prevEl && $prevEl[0]
      });
      if (!swiper2.enabled) {
        if ($nextEl) $nextEl.addClass(params.lockClass);
        if ($prevEl) $prevEl.addClass(params.lockClass);
      }
    }
    function destroy() {
      const {
        $nextEl,
        $prevEl
      } = swiper2.navigation;
      if ($nextEl && $nextEl.length) {
        $nextEl.off("click", onNextClick);
        $nextEl.removeClass(swiper2.params.navigation.disabledClass);
      }
      if ($prevEl && $prevEl.length) {
        $prevEl.off("click", onPrevClick);
        $prevEl.removeClass(swiper2.params.navigation.disabledClass);
      }
    }
    on2("init", () => {
      if (swiper2.params.navigation.enabled === false) {
        disable();
      } else {
        init();
        update();
      }
    });
    on2("toEdge fromEdge lock unlock", () => {
      update();
    });
    on2("destroy", () => {
      destroy();
    });
    on2("enable disable", () => {
      const {
        $nextEl,
        $prevEl
      } = swiper2.navigation;
      if ($nextEl) {
        $nextEl[swiper2.enabled ? "removeClass" : "addClass"](swiper2.params.navigation.lockClass);
      }
      if ($prevEl) {
        $prevEl[swiper2.enabled ? "removeClass" : "addClass"](swiper2.params.navigation.lockClass);
      }
    });
    on2("click", (_s, e) => {
      const {
        $nextEl,
        $prevEl
      } = swiper2.navigation;
      const targetEl = e.target;
      if (swiper2.params.navigation.hideOnClick && !dom_default(targetEl).is($prevEl) && !dom_default(targetEl).is($nextEl)) {
        if (swiper2.pagination && swiper2.params.pagination && swiper2.params.pagination.clickable && (swiper2.pagination.el === targetEl || swiper2.pagination.el.contains(targetEl))) return;
        let isHidden;
        if ($nextEl) {
          isHidden = $nextEl.hasClass(swiper2.params.navigation.hiddenClass);
        } else if ($prevEl) {
          isHidden = $prevEl.hasClass(swiper2.params.navigation.hiddenClass);
        }
        if (isHidden === true) {
          emit("navigationShow");
        } else {
          emit("navigationHide");
        }
        if ($nextEl) {
          $nextEl.toggleClass(swiper2.params.navigation.hiddenClass);
        }
        if ($prevEl) {
          $prevEl.toggleClass(swiper2.params.navigation.hiddenClass);
        }
      }
    });
    const enable = () => {
      swiper2.$el.removeClass(swiper2.params.navigation.navigationDisabledClass);
      init();
      update();
    };
    const disable = () => {
      swiper2.$el.addClass(swiper2.params.navigation.navigationDisabledClass);
      destroy();
    };
    Object.assign(swiper2.navigation, {
      enable,
      disable,
      update,
      init,
      destroy
    });
  }

  // node_modules/swiper/shared/classes-to-selector.js
  function classesToSelector(classes = "") {
    return `.${classes.trim().replace(/([\.:!\/])/g, "\\$1").replace(/ /g, ".")}`;
  }

  // node_modules/swiper/modules/pagination/pagination.js
  function Pagination({
    swiper: swiper2,
    extendParams,
    on: on2,
    emit
  }) {
    const pfx = "swiper-pagination";
    extendParams({
      pagination: {
        el: null,
        bulletElement: "span",
        clickable: false,
        hideOnClick: false,
        renderBullet: null,
        renderProgressbar: null,
        renderFraction: null,
        renderCustom: null,
        progressbarOpposite: false,
        type: "bullets",
        // 'bullets' or 'progressbar' or 'fraction' or 'custom'
        dynamicBullets: false,
        dynamicMainBullets: 1,
        formatFractionCurrent: (number) => number,
        formatFractionTotal: (number) => number,
        bulletClass: `${pfx}-bullet`,
        bulletActiveClass: `${pfx}-bullet-active`,
        modifierClass: `${pfx}-`,
        currentClass: `${pfx}-current`,
        totalClass: `${pfx}-total`,
        hiddenClass: `${pfx}-hidden`,
        progressbarFillClass: `${pfx}-progressbar-fill`,
        progressbarOppositeClass: `${pfx}-progressbar-opposite`,
        clickableClass: `${pfx}-clickable`,
        lockClass: `${pfx}-lock`,
        horizontalClass: `${pfx}-horizontal`,
        verticalClass: `${pfx}-vertical`,
        paginationDisabledClass: `${pfx}-disabled`
      }
    });
    swiper2.pagination = {
      el: null,
      $el: null,
      bullets: []
    };
    let bulletSize;
    let dynamicBulletIndex = 0;
    function isPaginationDisabled() {
      return !swiper2.params.pagination.el || !swiper2.pagination.el || !swiper2.pagination.$el || swiper2.pagination.$el.length === 0;
    }
    function setSideBullets($bulletEl, position) {
      const {
        bulletActiveClass
      } = swiper2.params.pagination;
      $bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);
    }
    function update() {
      const rtl = swiper2.rtl;
      const params = swiper2.params.pagination;
      if (isPaginationDisabled()) return;
      const slidesLength = swiper2.virtual && swiper2.params.virtual.enabled ? swiper2.virtual.slides.length : swiper2.slides.length;
      const $el = swiper2.pagination.$el;
      let current;
      const total = swiper2.params.loop ? Math.ceil((slidesLength - swiper2.loopedSlides * 2) / swiper2.params.slidesPerGroup) : swiper2.snapGrid.length;
      if (swiper2.params.loop) {
        current = Math.ceil((swiper2.activeIndex - swiper2.loopedSlides) / swiper2.params.slidesPerGroup);
        if (current > slidesLength - 1 - swiper2.loopedSlides * 2) {
          current -= slidesLength - swiper2.loopedSlides * 2;
        }
        if (current > total - 1) current -= total;
        if (current < 0 && swiper2.params.paginationType !== "bullets") current = total + current;
      } else if (typeof swiper2.snapIndex !== "undefined") {
        current = swiper2.snapIndex;
      } else {
        current = swiper2.activeIndex || 0;
      }
      if (params.type === "bullets" && swiper2.pagination.bullets && swiper2.pagination.bullets.length > 0) {
        const bullets = swiper2.pagination.bullets;
        let firstIndex;
        let lastIndex;
        let midIndex;
        if (params.dynamicBullets) {
          bulletSize = bullets.eq(0)[swiper2.isHorizontal() ? "outerWidth" : "outerHeight"](true);
          $el.css(swiper2.isHorizontal() ? "width" : "height", `${bulletSize * (params.dynamicMainBullets + 4)}px`);
          if (params.dynamicMainBullets > 1 && swiper2.previousIndex !== void 0) {
            dynamicBulletIndex += current - (swiper2.previousIndex - swiper2.loopedSlides || 0);
            if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
              dynamicBulletIndex = params.dynamicMainBullets - 1;
            } else if (dynamicBulletIndex < 0) {
              dynamicBulletIndex = 0;
            }
          }
          firstIndex = Math.max(current - dynamicBulletIndex, 0);
          lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
          midIndex = (lastIndex + firstIndex) / 2;
        }
        bullets.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((suffix) => `${params.bulletActiveClass}${suffix}`).join(" "));
        if ($el.length > 1) {
          bullets.each((bullet) => {
            const $bullet = dom_default(bullet);
            const bulletIndex = $bullet.index();
            if (bulletIndex === current) {
              $bullet.addClass(params.bulletActiveClass);
            }
            if (params.dynamicBullets) {
              if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                $bullet.addClass(`${params.bulletActiveClass}-main`);
              }
              if (bulletIndex === firstIndex) {
                setSideBullets($bullet, "prev");
              }
              if (bulletIndex === lastIndex) {
                setSideBullets($bullet, "next");
              }
            }
          });
        } else {
          const $bullet = bullets.eq(current);
          const bulletIndex = $bullet.index();
          $bullet.addClass(params.bulletActiveClass);
          if (params.dynamicBullets) {
            const $firstDisplayedBullet = bullets.eq(firstIndex);
            const $lastDisplayedBullet = bullets.eq(lastIndex);
            for (let i = firstIndex; i <= lastIndex; i += 1) {
              bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
            }
            if (swiper2.params.loop) {
              if (bulletIndex >= bullets.length) {
                for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
                  bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
                }
                bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
              } else {
                setSideBullets($firstDisplayedBullet, "prev");
                setSideBullets($lastDisplayedBullet, "next");
              }
            } else {
              setSideBullets($firstDisplayedBullet, "prev");
              setSideBullets($lastDisplayedBullet, "next");
            }
          }
        }
        if (params.dynamicBullets) {
          const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
          const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
          const offsetProp = rtl ? "right" : "left";
          bullets.css(swiper2.isHorizontal() ? offsetProp : "top", `${bulletsOffset}px`);
        }
      }
      if (params.type === "fraction") {
        $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
        $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
      }
      if (params.type === "progressbar") {
        let progressbarDirection;
        if (params.progressbarOpposite) {
          progressbarDirection = swiper2.isHorizontal() ? "vertical" : "horizontal";
        } else {
          progressbarDirection = swiper2.isHorizontal() ? "horizontal" : "vertical";
        }
        const scale = (current + 1) / total;
        let scaleX = 1;
        let scaleY = 1;
        if (progressbarDirection === "horizontal") {
          scaleX = scale;
        } else {
          scaleY = scale;
        }
        $el.find(classesToSelector(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper2.params.speed);
      }
      if (params.type === "custom" && params.renderCustom) {
        $el.html(params.renderCustom(swiper2, current + 1, total));
        emit("paginationRender", $el[0]);
      } else {
        emit("paginationUpdate", $el[0]);
      }
      if (swiper2.params.watchOverflow && swiper2.enabled) {
        $el[swiper2.isLocked ? "addClass" : "removeClass"](params.lockClass);
      }
    }
    function render() {
      const params = swiper2.params.pagination;
      if (isPaginationDisabled()) return;
      const slidesLength = swiper2.virtual && swiper2.params.virtual.enabled ? swiper2.virtual.slides.length : swiper2.slides.length;
      const $el = swiper2.pagination.$el;
      let paginationHTML = "";
      if (params.type === "bullets") {
        let numberOfBullets = swiper2.params.loop ? Math.ceil((slidesLength - swiper2.loopedSlides * 2) / swiper2.params.slidesPerGroup) : swiper2.snapGrid.length;
        if (swiper2.params.freeMode && swiper2.params.freeMode.enabled && !swiper2.params.loop && numberOfBullets > slidesLength) {
          numberOfBullets = slidesLength;
        }
        for (let i = 0; i < numberOfBullets; i += 1) {
          if (params.renderBullet) {
            paginationHTML += params.renderBullet.call(swiper2, i, params.bulletClass);
          } else {
            paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
          }
        }
        $el.html(paginationHTML);
        swiper2.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
      }
      if (params.type === "fraction") {
        if (params.renderFraction) {
          paginationHTML = params.renderFraction.call(swiper2, params.currentClass, params.totalClass);
        } else {
          paginationHTML = `<span class="${params.currentClass}"></span> / <span class="${params.totalClass}"></span>`;
        }
        $el.html(paginationHTML);
      }
      if (params.type === "progressbar") {
        if (params.renderProgressbar) {
          paginationHTML = params.renderProgressbar.call(swiper2, params.progressbarFillClass);
        } else {
          paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
        }
        $el.html(paginationHTML);
      }
      if (params.type !== "custom") {
        emit("paginationRender", swiper2.pagination.$el[0]);
      }
    }
    function init() {
      swiper2.params.pagination = createElementIfNotDefined(swiper2, swiper2.originalParams.pagination, swiper2.params.pagination, {
        el: "swiper-pagination"
      });
      const params = swiper2.params.pagination;
      if (!params.el) return;
      let $el = dom_default(params.el);
      if ($el.length === 0) return;
      if (swiper2.params.uniqueNavElements && typeof params.el === "string" && $el.length > 1) {
        $el = swiper2.$el.find(params.el);
        if ($el.length > 1) {
          $el = $el.filter((el) => {
            if (dom_default(el).parents(".swiper")[0] !== swiper2.el) return false;
            return true;
          });
        }
      }
      if (params.type === "bullets" && params.clickable) {
        $el.addClass(params.clickableClass);
      }
      $el.addClass(params.modifierClass + params.type);
      $el.addClass(swiper2.isHorizontal() ? params.horizontalClass : params.verticalClass);
      if (params.type === "bullets" && params.dynamicBullets) {
        $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
        dynamicBulletIndex = 0;
        if (params.dynamicMainBullets < 1) {
          params.dynamicMainBullets = 1;
        }
      }
      if (params.type === "progressbar" && params.progressbarOpposite) {
        $el.addClass(params.progressbarOppositeClass);
      }
      if (params.clickable) {
        $el.on("click", classesToSelector(params.bulletClass), function onClick2(e) {
          e.preventDefault();
          let index2 = dom_default(this).index() * swiper2.params.slidesPerGroup;
          if (swiper2.params.loop) index2 += swiper2.loopedSlides;
          swiper2.slideTo(index2);
        });
      }
      Object.assign(swiper2.pagination, {
        $el,
        el: $el[0]
      });
      if (!swiper2.enabled) {
        $el.addClass(params.lockClass);
      }
    }
    function destroy() {
      const params = swiper2.params.pagination;
      if (isPaginationDisabled()) return;
      const $el = swiper2.pagination.$el;
      $el.removeClass(params.hiddenClass);
      $el.removeClass(params.modifierClass + params.type);
      $el.removeClass(swiper2.isHorizontal() ? params.horizontalClass : params.verticalClass);
      if (swiper2.pagination.bullets && swiper2.pagination.bullets.removeClass) swiper2.pagination.bullets.removeClass(params.bulletActiveClass);
      if (params.clickable) {
        $el.off("click", classesToSelector(params.bulletClass));
      }
    }
    on2("init", () => {
      if (swiper2.params.pagination.enabled === false) {
        disable();
      } else {
        init();
        render();
        update();
      }
    });
    on2("activeIndexChange", () => {
      if (swiper2.params.loop) {
        update();
      } else if (typeof swiper2.snapIndex === "undefined") {
        update();
      }
    });
    on2("snapIndexChange", () => {
      if (!swiper2.params.loop) {
        update();
      }
    });
    on2("slidesLengthChange", () => {
      if (swiper2.params.loop) {
        render();
        update();
      }
    });
    on2("snapGridLengthChange", () => {
      if (!swiper2.params.loop) {
        render();
        update();
      }
    });
    on2("destroy", () => {
      destroy();
    });
    on2("enable disable", () => {
      const {
        $el
      } = swiper2.pagination;
      if ($el) {
        $el[swiper2.enabled ? "removeClass" : "addClass"](swiper2.params.pagination.lockClass);
      }
    });
    on2("lock unlock", () => {
      update();
    });
    on2("click", (_s, e) => {
      const targetEl = e.target;
      const {
        $el
      } = swiper2.pagination;
      if (swiper2.params.pagination.el && swiper2.params.pagination.hideOnClick && $el && $el.length > 0 && !dom_default(targetEl).hasClass(swiper2.params.pagination.bulletClass)) {
        if (swiper2.navigation && (swiper2.navigation.nextEl && targetEl === swiper2.navigation.nextEl || swiper2.navigation.prevEl && targetEl === swiper2.navigation.prevEl)) return;
        const isHidden = $el.hasClass(swiper2.params.pagination.hiddenClass);
        if (isHidden === true) {
          emit("paginationShow");
        } else {
          emit("paginationHide");
        }
        $el.toggleClass(swiper2.params.pagination.hiddenClass);
      }
    });
    const enable = () => {
      swiper2.$el.removeClass(swiper2.params.pagination.paginationDisabledClass);
      if (swiper2.pagination.$el) {
        swiper2.pagination.$el.removeClass(swiper2.params.pagination.paginationDisabledClass);
      }
      init();
      render();
      update();
    };
    const disable = () => {
      swiper2.$el.addClass(swiper2.params.pagination.paginationDisabledClass);
      if (swiper2.pagination.$el) {
        swiper2.pagination.$el.addClass(swiper2.params.pagination.paginationDisabledClass);
      }
      destroy();
    };
    Object.assign(swiper2.pagination, {
      enable,
      disable,
      render,
      update,
      init,
      destroy
    });
  }

  // node_modules/swiper/modules/autoplay/autoplay.js
  function Autoplay({
    swiper: swiper2,
    extendParams,
    on: on2,
    emit
  }) {
    let timeout;
    swiper2.autoplay = {
      running: false,
      paused: false
    };
    extendParams({
      autoplay: {
        enabled: false,
        delay: 3e3,
        waitForTransition: true,
        disableOnInteraction: true,
        stopOnLastSlide: false,
        reverseDirection: false,
        pauseOnMouseEnter: false
      }
    });
    function run() {
      if (!swiper2.size) {
        swiper2.autoplay.running = false;
        swiper2.autoplay.paused = false;
        return;
      }
      const $activeSlideEl = swiper2.slides.eq(swiper2.activeIndex);
      let delay = swiper2.params.autoplay.delay;
      if ($activeSlideEl.attr("data-swiper-autoplay")) {
        delay = $activeSlideEl.attr("data-swiper-autoplay") || swiper2.params.autoplay.delay;
      }
      clearTimeout(timeout);
      timeout = nextTick(() => {
        let autoplayResult;
        if (swiper2.params.autoplay.reverseDirection) {
          if (swiper2.params.loop) {
            swiper2.loopFix();
            autoplayResult = swiper2.slidePrev(swiper2.params.speed, true, true);
            emit("autoplay");
          } else if (!swiper2.isBeginning) {
            autoplayResult = swiper2.slidePrev(swiper2.params.speed, true, true);
            emit("autoplay");
          } else if (!swiper2.params.autoplay.stopOnLastSlide) {
            autoplayResult = swiper2.slideTo(swiper2.slides.length - 1, swiper2.params.speed, true, true);
            emit("autoplay");
          } else {
            stop();
          }
        } else if (swiper2.params.loop) {
          swiper2.loopFix();
          autoplayResult = swiper2.slideNext(swiper2.params.speed, true, true);
          emit("autoplay");
        } else if (!swiper2.isEnd) {
          autoplayResult = swiper2.slideNext(swiper2.params.speed, true, true);
          emit("autoplay");
        } else if (!swiper2.params.autoplay.stopOnLastSlide) {
          autoplayResult = swiper2.slideTo(0, swiper2.params.speed, true, true);
          emit("autoplay");
        } else {
          stop();
        }
        if (swiper2.params.cssMode && swiper2.autoplay.running) run();
        else if (autoplayResult === false) {
          run();
        }
      }, delay);
    }
    function start() {
      if (typeof timeout !== "undefined") return false;
      if (swiper2.autoplay.running) return false;
      swiper2.autoplay.running = true;
      emit("autoplayStart");
      run();
      return true;
    }
    function stop() {
      if (!swiper2.autoplay.running) return false;
      if (typeof timeout === "undefined") return false;
      if (timeout) {
        clearTimeout(timeout);
        timeout = void 0;
      }
      swiper2.autoplay.running = false;
      emit("autoplayStop");
      return true;
    }
    function pause(speed) {
      if (!swiper2.autoplay.running) return;
      if (swiper2.autoplay.paused) return;
      if (timeout) clearTimeout(timeout);
      swiper2.autoplay.paused = true;
      if (speed === 0 || !swiper2.params.autoplay.waitForTransition) {
        swiper2.autoplay.paused = false;
        run();
      } else {
        ["transitionend", "webkitTransitionEnd"].forEach((event2) => {
          swiper2.$wrapperEl[0].addEventListener(event2, onTransitionEnd);
        });
      }
    }
    function onVisibilityChange() {
      const document2 = getDocument();
      if (document2.visibilityState === "hidden" && swiper2.autoplay.running) {
        pause();
      }
      if (document2.visibilityState === "visible" && swiper2.autoplay.paused) {
        run();
        swiper2.autoplay.paused = false;
      }
    }
    function onTransitionEnd(e) {
      if (!swiper2 || swiper2.destroyed || !swiper2.$wrapperEl) return;
      if (e.target !== swiper2.$wrapperEl[0]) return;
      ["transitionend", "webkitTransitionEnd"].forEach((event2) => {
        swiper2.$wrapperEl[0].removeEventListener(event2, onTransitionEnd);
      });
      swiper2.autoplay.paused = false;
      if (!swiper2.autoplay.running) {
        stop();
      } else {
        run();
      }
    }
    function onMouseEnter() {
      if (swiper2.params.autoplay.disableOnInteraction) {
        stop();
      } else {
        emit("autoplayPause");
        pause();
      }
      ["transitionend", "webkitTransitionEnd"].forEach((event2) => {
        swiper2.$wrapperEl[0].removeEventListener(event2, onTransitionEnd);
      });
    }
    function onMouseLeave() {
      if (swiper2.params.autoplay.disableOnInteraction) {
        return;
      }
      swiper2.autoplay.paused = false;
      emit("autoplayResume");
      run();
    }
    function attachMouseEvents() {
      if (swiper2.params.autoplay.pauseOnMouseEnter) {
        swiper2.$el.on("mouseenter", onMouseEnter);
        swiper2.$el.on("mouseleave", onMouseLeave);
      }
    }
    function detachMouseEvents() {
      swiper2.$el.off("mouseenter", onMouseEnter);
      swiper2.$el.off("mouseleave", onMouseLeave);
    }
    on2("init", () => {
      if (swiper2.params.autoplay.enabled) {
        start();
        const document2 = getDocument();
        document2.addEventListener("visibilitychange", onVisibilityChange);
        attachMouseEvents();
      }
    });
    on2("beforeTransitionStart", (_s, speed, internal) => {
      if (swiper2.autoplay.running) {
        if (internal || !swiper2.params.autoplay.disableOnInteraction) {
          swiper2.autoplay.pause(speed);
        } else {
          stop();
        }
      }
    });
    on2("sliderFirstMove", () => {
      if (swiper2.autoplay.running) {
        if (swiper2.params.autoplay.disableOnInteraction) {
          stop();
        } else {
          pause();
        }
      }
    });
    on2("touchEnd", () => {
      if (swiper2.params.cssMode && swiper2.autoplay.paused && !swiper2.params.autoplay.disableOnInteraction) {
        run();
      }
    });
    on2("destroy", () => {
      detachMouseEvents();
      if (swiper2.autoplay.running) {
        stop();
      }
      const document2 = getDocument();
      document2.removeEventListener("visibilitychange", onVisibilityChange);
    });
    Object.assign(swiper2.autoplay, {
      pause,
      run,
      start,
      stop
    });
  }

  // node_modules/swiper/modules/thumbs/thumbs.js
  function Thumb({
    swiper: swiper2,
    extendParams,
    on: on2
  }) {
    extendParams({
      thumbs: {
        swiper: null,
        multipleActiveThumbs: true,
        autoScrollOffset: 0,
        slideThumbActiveClass: "swiper-slide-thumb-active",
        thumbsContainerClass: "swiper-thumbs"
      }
    });
    let initialized = false;
    let swiperCreated = false;
    swiper2.thumbs = {
      swiper: null
    };
    function onThumbClick() {
      const thumbsSwiper = swiper2.thumbs.swiper;
      if (!thumbsSwiper || thumbsSwiper.destroyed) return;
      const clickedIndex = thumbsSwiper.clickedIndex;
      const clickedSlide = thumbsSwiper.clickedSlide;
      if (clickedSlide && dom_default(clickedSlide).hasClass(swiper2.params.thumbs.slideThumbActiveClass)) return;
      if (typeof clickedIndex === "undefined" || clickedIndex === null) return;
      let slideToIndex;
      if (thumbsSwiper.params.loop) {
        slideToIndex = parseInt(dom_default(thumbsSwiper.clickedSlide).attr("data-swiper-slide-index"), 10);
      } else {
        slideToIndex = clickedIndex;
      }
      if (swiper2.params.loop) {
        let currentIndex2 = swiper2.activeIndex;
        if (swiper2.slides.eq(currentIndex2).hasClass(swiper2.params.slideDuplicateClass)) {
          swiper2.loopFix();
          swiper2._clientLeft = swiper2.$wrapperEl[0].clientLeft;
          currentIndex2 = swiper2.activeIndex;
        }
        const prevIndex = swiper2.slides.eq(currentIndex2).prevAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
        const nextIndex = swiper2.slides.eq(currentIndex2).nextAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
        if (typeof prevIndex === "undefined") slideToIndex = nextIndex;
        else if (typeof nextIndex === "undefined") slideToIndex = prevIndex;
        else if (nextIndex - currentIndex2 < currentIndex2 - prevIndex) slideToIndex = nextIndex;
        else slideToIndex = prevIndex;
      }
      swiper2.slideTo(slideToIndex);
    }
    function init() {
      const {
        thumbs: thumbsParams
      } = swiper2.params;
      if (initialized) return false;
      initialized = true;
      const SwiperClass = swiper2.constructor;
      if (thumbsParams.swiper instanceof SwiperClass) {
        swiper2.thumbs.swiper = thumbsParams.swiper;
        Object.assign(swiper2.thumbs.swiper.originalParams, {
          watchSlidesProgress: true,
          slideToClickedSlide: false
        });
        Object.assign(swiper2.thumbs.swiper.params, {
          watchSlidesProgress: true,
          slideToClickedSlide: false
        });
      } else if (isObject2(thumbsParams.swiper)) {
        const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
        Object.assign(thumbsSwiperParams, {
          watchSlidesProgress: true,
          slideToClickedSlide: false
        });
        swiper2.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
        swiperCreated = true;
      }
      swiper2.thumbs.swiper.$el.addClass(swiper2.params.thumbs.thumbsContainerClass);
      swiper2.thumbs.swiper.on("tap", onThumbClick);
      return true;
    }
    function update(initial) {
      const thumbsSwiper = swiper2.thumbs.swiper;
      if (!thumbsSwiper || thumbsSwiper.destroyed) return;
      const slidesPerView = thumbsSwiper.params.slidesPerView === "auto" ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
      let thumbsToActivate = 1;
      const thumbActiveClass = swiper2.params.thumbs.slideThumbActiveClass;
      if (swiper2.params.slidesPerView > 1 && !swiper2.params.centeredSlides) {
        thumbsToActivate = swiper2.params.slidesPerView;
      }
      if (!swiper2.params.thumbs.multipleActiveThumbs) {
        thumbsToActivate = 1;
      }
      thumbsToActivate = Math.floor(thumbsToActivate);
      thumbsSwiper.slides.removeClass(thumbActiveClass);
      if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
        for (let i = 0; i < thumbsToActivate; i += 1) {
          thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index="${swiper2.realIndex + i}"]`).addClass(thumbActiveClass);
        }
      } else {
        for (let i = 0; i < thumbsToActivate; i += 1) {
          thumbsSwiper.slides.eq(swiper2.realIndex + i).addClass(thumbActiveClass);
        }
      }
      const autoScrollOffset = swiper2.params.thumbs.autoScrollOffset;
      const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
      if (swiper2.realIndex !== thumbsSwiper.realIndex || useOffset) {
        let currentThumbsIndex = thumbsSwiper.activeIndex;
        let newThumbsIndex;
        let direction;
        if (thumbsSwiper.params.loop) {
          if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
            thumbsSwiper.loopFix();
            thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
            currentThumbsIndex = thumbsSwiper.activeIndex;
          }
          const prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(`[data-swiper-slide-index="${swiper2.realIndex}"]`).eq(0).index();
          const nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(`[data-swiper-slide-index="${swiper2.realIndex}"]`).eq(0).index();
          if (typeof prevThumbsIndex === "undefined") {
            newThumbsIndex = nextThumbsIndex;
          } else if (typeof nextThumbsIndex === "undefined") {
            newThumbsIndex = prevThumbsIndex;
          } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
            newThumbsIndex = thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;
          } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
            newThumbsIndex = nextThumbsIndex;
          } else {
            newThumbsIndex = prevThumbsIndex;
          }
          direction = swiper2.activeIndex > swiper2.previousIndex ? "next" : "prev";
        } else {
          newThumbsIndex = swiper2.realIndex;
          direction = newThumbsIndex > swiper2.previousIndex ? "next" : "prev";
        }
        if (useOffset) {
          newThumbsIndex += direction === "next" ? autoScrollOffset : -1 * autoScrollOffset;
        }
        if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
          if (thumbsSwiper.params.centeredSlides) {
            if (newThumbsIndex > currentThumbsIndex) {
              newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
            } else {
              newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
            }
          } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) {
          }
          thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : void 0);
        }
      }
    }
    on2("beforeInit", () => {
      const {
        thumbs
      } = swiper2.params;
      if (!thumbs || !thumbs.swiper) return;
      init();
      update(true);
    });
    on2("slideChange update resize observerUpdate", () => {
      update();
    });
    on2("setTransition", (_s, duration) => {
      const thumbsSwiper = swiper2.thumbs.swiper;
      if (!thumbsSwiper || thumbsSwiper.destroyed) return;
      thumbsSwiper.setTransition(duration);
    });
    on2("beforeDestroy", () => {
      const thumbsSwiper = swiper2.thumbs.swiper;
      if (!thumbsSwiper || thumbsSwiper.destroyed) return;
      if (swiperCreated) {
        thumbsSwiper.destroy();
      }
    });
    Object.assign(swiper2.thumbs, {
      init,
      update
    });
  }

  // node_modules/swiper/shared/effect-init.js
  function effectInit(params) {
    const {
      effect,
      swiper: swiper2,
      on: on2,
      setTranslate: setTranslate2,
      setTransition: setTransition2,
      overwriteParams,
      perspective,
      recreateShadows,
      getEffectParams
    } = params;
    on2("beforeInit", () => {
      if (swiper2.params.effect !== effect) return;
      swiper2.classNames.push(`${swiper2.params.containerModifierClass}${effect}`);
      if (perspective && perspective()) {
        swiper2.classNames.push(`${swiper2.params.containerModifierClass}3d`);
      }
      const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
      Object.assign(swiper2.params, overwriteParamsResult);
      Object.assign(swiper2.originalParams, overwriteParamsResult);
    });
    on2("setTranslate", () => {
      if (swiper2.params.effect !== effect) return;
      setTranslate2();
    });
    on2("setTransition", (_s, duration) => {
      if (swiper2.params.effect !== effect) return;
      setTransition2(duration);
    });
    on2("transitionEnd", () => {
      if (swiper2.params.effect !== effect) return;
      if (recreateShadows) {
        if (!getEffectParams || !getEffectParams().slideShadows) return;
        swiper2.slides.each((slideEl) => {
          const $slideEl = swiper2.$(slideEl);
          $slideEl.find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").remove();
        });
        recreateShadows();
      }
    });
    let requireUpdateOnVirtual;
    on2("virtualUpdate", () => {
      if (swiper2.params.effect !== effect) return;
      if (!swiper2.slides.length) {
        requireUpdateOnVirtual = true;
      }
      requestAnimationFrame(() => {
        if (requireUpdateOnVirtual && swiper2.slides && swiper2.slides.length) {
          setTranslate2();
          requireUpdateOnVirtual = false;
        }
      });
    });
  }

  // node_modules/swiper/shared/effect-target.js
  function effectTarget(effectParams, $slideEl) {
    if (effectParams.transformEl) {
      return $slideEl.find(effectParams.transformEl).css({
        "backface-visibility": "hidden",
        "-webkit-backface-visibility": "hidden"
      });
    }
    return $slideEl;
  }

  // node_modules/swiper/shared/effect-virtual-transition-end.js
  function effectVirtualTransitionEnd({
    swiper: swiper2,
    duration,
    transformEl,
    allSlides
  }) {
    const {
      slides,
      activeIndex,
      $wrapperEl
    } = swiper2;
    if (swiper2.params.virtualTranslate && duration !== 0) {
      let eventTriggered = false;
      let $transitionEndTarget;
      if (allSlides) {
        $transitionEndTarget = transformEl ? slides.find(transformEl) : slides;
      } else {
        $transitionEndTarget = transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex);
      }
      $transitionEndTarget.transitionEnd(() => {
        if (eventTriggered) return;
        if (!swiper2 || swiper2.destroyed) return;
        eventTriggered = true;
        swiper2.animating = false;
        const triggerEvents = ["webkitTransitionEnd", "transitionend"];
        for (let i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  }

  // node_modules/swiper/modules/effect-fade/effect-fade.js
  function EffectFade({
    swiper: swiper2,
    extendParams,
    on: on2
  }) {
    extendParams({
      fadeEffect: {
        crossFade: false,
        transformEl: null
      }
    });
    const setTranslate2 = () => {
      const {
        slides
      } = swiper2;
      const params = swiper2.params.fadeEffect;
      for (let i = 0; i < slides.length; i += 1) {
        const $slideEl = swiper2.slides.eq(i);
        const offset2 = $slideEl[0].swiperSlideOffset;
        let tx = -offset2;
        if (!swiper2.params.virtualTranslate) tx -= swiper2.translate;
        let ty = 0;
        if (!swiper2.isHorizontal()) {
          ty = tx;
          tx = 0;
        }
        const slideOpacity = swiper2.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
        const $targetEl = effectTarget(params, $slideEl);
        $targetEl.css({
          opacity: slideOpacity
        }).transform(`translate3d(${tx}px, ${ty}px, 0px)`);
      }
    };
    const setTransition2 = (duration) => {
      const {
        transformEl
      } = swiper2.params.fadeEffect;
      const $transitionElements = transformEl ? swiper2.slides.find(transformEl) : swiper2.slides;
      $transitionElements.transition(duration);
      effectVirtualTransitionEnd({
        swiper: swiper2,
        duration,
        transformEl,
        allSlides: true
      });
    };
    effectInit({
      effect: "fade",
      swiper: swiper2,
      on: on2,
      setTranslate: setTranslate2,
      setTransition: setTransition2,
      overwriteParams: () => ({
        slidesPerView: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: !swiper2.params.cssMode
      })
    });
  }

  // src/js/main.js
  var pagination = {
    limit: 5,
    current: 1,
    count: 0
  };
  var state = {
    search: "",
    paid: null,
    language: [],
    topic: [],
    level: []
  };
  var result = data_default;
  var renderMarkup = (input, index2 = 1) => {
    const sortedData = sortData(input);
    const items = paginationOffset(sortedData, index2);
    let output = "";
    items.map((item) => {
      const markup = `
			<article class="article">
				<figure class="article-thumb">
					<a href="gallery.html"><img src="${item.image}" alt="${item.title}" width="300" height="300" loading="lazy"></a>
				</figure>
				<div class="article-content h4">
					<h3 class="h4 article-title"><a href="gallery.html">${item.title}</a></h3>
					<p class="article-subtitle">${item.description}</p>
					<div>${item.language.map((tag) => `<span class="tag tag-grey">${tag}</span>`).join("")}</div>
					<div><span class="tag">${item.topic}</span></div>
					<div><span class="tag tag-purple-dark">${item.level}</span></div>
					<span class="article-author">${item.authors}</span>
					<span class="article-price">${item.paid ? item.price : `<del>${item.price}</del><span class="tag tag-green">FREE</span>`}</span>
				</div>
			</article>
		`;
      return output += markup;
    });
    if (output === "") {
      document.querySelector("#root").innerHTML = '<p class="h1">No results</p>';
    } else {
      document.querySelector("#root").innerHTML = output;
    }
  };
  var sortData = (result2) => {
    const value = document.querySelector(".sort").value;
    switch (value) {
      case "0":
        return result2.sort((a, b) => a.id - b.id);
      case "1":
        return result2.sort((a, b) => parseFloat(a.price) - parseFloat(b.price));
      case "2":
        return result2.sort((a, b) => parseFloat(b.price) - parseFloat(a.price));
      case "3":
        return result2.sort((a, b) => a.title.localeCompare(b.title));
      case "4":
        return result2.sort((a, b) => b.title.localeCompare(a.title));
      default:
        return result2;
    }
  };
  var filterData = () => {
    const { search, paid, language, topic, level } = state;
    result = data_default;
    if (search) {
      result = result.filter((item) => item.title.toLowerCase().includes(search.toLowerCase()));
    }
    if (paid !== null) {
      result = result.filter((item) => item.paid === paid);
    }
    if (language.length) {
      result = result.filter((item) => language.some((lang) => item.language.includes(lang)));
    }
    if (topic.length) {
      result = result.filter((item) => topic.includes(item.topic));
    }
    if (level.length) {
      result = result.filter((item) => level.includes(item.level));
    }
    renderMarkup(result);
  };
  var resetFilters = () => {
    [...document.querySelectorAll(".filter-input")].map((item) => {
      item.checked = false;
    });
    state = {
      ...state,
      paid: null,
      language: [],
      topic: [],
      level: []
    };
    filterData();
  };
  var paginationOffset = (result2, index2) => {
    let max = pagination.limit * index2, min = max - pagination.limit;
    pagination.count = Math.ceil(result2.length / pagination.limit);
    pagination.current = index2;
    if (pagination.count > 1) {
      let markup = `<nav class="pagination">`;
      if (pagination.current > 1) {
        markup += `<a class="prev page">&lt;</a>`;
      }
      let end = Math.min(Math.max(index2 + 3, 6), pagination.count);
      let start = Math.max(Math.min(index2 - 3, pagination.count - 6), 1);
      for (let i = start; i <= end; i++) {
        if (i === index2) {
          markup += `<span class="page current">${i}</span>`;
        } else {
          markup += `<a class="page">${i}</a>`;
        }
      }
      if (pagination.current < pagination.count) {
        markup += `<a class="next page">&gt;</a>`;
      }
      markup += `</nav>`;
      document.querySelector("#pagination").innerHTML = markup;
    } else {
      document.querySelector("#pagination").innerHTML = "";
    }
    result2 = result2.slice(min, max);
    console.log(pagination);
    return result2;
  };
  document.addEventListener("DOMContentLoaded", () => {
    if (document.querySelector("#root")) resetFilters();
  });
  document.addEventListener("change", (e) => {
    if (e.target.matches(".filter-input")) {
      let inputName = e.target.name, key = inputName.split("-")[1], value = [], isArray = e.target.type !== "radio";
      [...document.querySelectorAll('input[name="' + inputName + '"]')].map((item) => {
        if (item.checked) {
          value = isArray ? [...value, item.value] : item.value == "1" ? true : false;
        }
      });
      if (state.hasOwnProperty(key)) {
        state[key] = value;
      }
      filterData();
    }
  });
  document.addEventListener("submit", (e) => {
    if (e.target.matches(".search-form")) {
      e.preventDefault();
      state.search = document.querySelector(".search-input").value;
      filterData();
    }
  });
  document.addEventListener("click", (e) => {
    if (e.target.matches(".page")) {
      if (e.target.matches(".prev")) {
        if (pagination.current > 1) {
          renderMarkup(result, pagination.current - 1);
          document.getElementById("scroll-anchor").scrollIntoView({ behavior: "smooth", block: "start", inline: "nearest" });
        }
      } else if (e.target.matches(".next")) {
        if (pagination.current < pagination.count) {
          renderMarkup(result, pagination.current + 1);
          document.getElementById("scroll-anchor").scrollIntoView({ behavior: "smooth", block: "start", inline: "nearest" });
        }
      } else {
        if (pagination.current !== parseInt(e.target.textContent)) {
          renderMarkup(result, parseInt(e.target.textContent));
          document.getElementById("scroll-anchor").scrollIntoView({ behavior: "smooth", block: "start", inline: "nearest" });
        }
      }
    }
  });
  document.addEventListener("change", () => {
    renderMarkup(result);
  });
  document.addEventListener("click", (e) => {
    if (e.target.matches(".filter-reset")) {
      resetFilters();
    }
  });
  document.addEventListener("click", (e) => {
    if (e.target.closest(".dropdown-selection")) {
      let trigger2 = e.target;
      let dest = e.target.closest(".dropdown");
      if (dest) {
        if (trigger2.classList.contains("inactive")) {
          trigger2.classList.remove("inactive");
          dest.classList.remove("inactive");
        } else {
          trigger2.classList.add("inactive");
          dest.classList.add("inactive");
        }
      }
    }
  });
  document.addEventListener("click", (e) => {
    if (e.target.closest(".trigger")) {
      let trigger2 = e.target.closest(".trigger");
      let dest = document.querySelector(trigger2.dataset.dest);
      if (dest) {
        if (trigger2.classList.contains("active")) {
          trigger2.classList.remove("active");
          dest.classList.remove("active");
        } else {
          trigger2.classList.add("active");
          dest.classList.add("active");
        }
      }
    }
  });
  var currentIndex = 0;
  var isTransitioning = false;
  function moveSlide(step) {
    if (isTransitioning) return;
    const slides = document.querySelectorAll(".slider .slide");
    const totalSlides = slides.length;
    currentIndex += step;
    if (currentIndex < 0) {
      currentIndex = totalSlides - 1;
    } else if (currentIndex >= totalSlides) {
      currentIndex = 0;
    }
    isTransitioning = true;
    const newTransformValue = -currentIndex * 100;
    document.querySelector(".slider").style.transform = `translateX(${newTransformValue}%)`;
    document.querySelector(".slider").addEventListener("transitionend", function onTransitionEnd() {
      isTransitioning = false;
      document.querySelector(".slider").removeEventListener("transitionend", onTransitionEnd);
      updateButtons();
    });
    updateButtons();
  }
  function updateButtons() {
    const slides = document.querySelectorAll(".slider .slide");
    const prevButtons = document.querySelectorAll(".slide-prev");
    const nextButtons = document.querySelectorAll(".slide-next");
    if (currentIndex === 0) {
      prevButtons.forEach((button) => button.disabled = true);
    } else {
      prevButtons.forEach((button) => button.disabled = false);
    }
    if (currentIndex === slides.length - 1) {
      nextButtons.forEach((button) => button.disabled = true);
    } else {
      nextButtons.forEach((button) => button.disabled = false);
    }
  }
  updateButtons();
  document.addEventListener("click", (e) => {
    if (e.target.matches(".slide-prev")) moveSlide(-1);
    if (e.target.matches(".slide-next")) moveSlide(1);
  });
  function swiper({
    element,
    options,
    nav = {}
  } = {}) {
    var $element = document.querySelector(element), $elements = document.querySelectorAll(element);
    this.initSwiper = function() {
      if ($element == null) return false;
      options = Object.assign({}, options, { modules: [Navigation, Pagination, EffectFade, Autoplay, Thumb] });
      if (nav.hasOwnProperty("element") && nav.hasOwnProperty("options")) {
        for (let i = 0; i < $elements.length; i++) {
          var swiperNav = new core_default(document.querySelectorAll(nav.element)[i], nav.options), thumbsNav = {
            thumbs: {
              swiper: swiperNav
            }
          };
          options = Object.assign({}, options, thumbsNav);
          new core_default($elements[i], options);
        }
        return false;
      }
      new core_default(element, options);
    };
  }
  var swiperGalleryOptions = {
    element: ".swiper-gallery .gallery-main",
    options: {
      rewind: true,
      effect: "fade",
      fadeEffect: {
        crossFade: true
      },
      navigation: {
        nextEl: ".swiper-gallery .gallery-main .swiper-button-next",
        prevEl: ".swiper-gallery .gallery-main .swiper-button-prev"
      }
    },
    nav: {
      element: ".swiper-gallery .gallery-thumbs",
      options: {
        spaceBetween: 10,
        slidesPerView: 4,
        freeMode: true,
        watchSlidesVisibility: true,
        watchSlidesProgress: true
      }
    }
  };
  var swiperGalleryModule = new swiper(swiperGalleryOptions);
  swiperGalleryModule.initSwiper();
})();
